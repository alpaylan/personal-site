<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Learner’s Guide to Dynamic Programming#1</title></head><body><article class="h-entry">

<section data-field="body" class="e-content">
<section name="63f9" class="section section--body section--first section--last"><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="8e5c" id="8e5c" class="graf graf--h3 graf--leading graf--title">Learner’s Guide to Dynamic Programming#1</h3><p name="cb1a" id="cb1a" class="graf graf--p graf-after--h3">Dynamic programming is an algorithmic problem solving paradigm focused on recognization and elimination of repetitive computation. For this article, I’ll write a short introduction to dynamic programming, and move on to explaining how I try to look at dynamic programming problems.</p><h3 name="ad20" id="ad20" class="graf graf--h3 graf-after--p"><strong class="markup--strong markup--h3-strong">Introduction to Dynamic Programming</strong></h3><p name="bcb5" id="bcb5" class="graf graf--p graf-after--h3">Dynamic programming rests on two simple properties of the algorithms and the problems it works on.</p><p name="5f87" id="5f87" class="graf graf--p graf-after--p">Firstly, a problem needs to have <strong class="markup--strong markup--p-strong">optimal substructure property</strong>, namely the property that it is possible to use results of an algorithm for a substructure to compute the results of an algorithm for the whole structure. Let’s demistify this a bit.</p><p name="2fad" id="2fad" class="graf graf--p graf-after--p">Let us look an implementation of array sum algorithm. One would write is as given below in Python in the iterative way.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="9944" id="9944" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">array</span>):<br />  res = <span class="hljs-number">0</span><br />  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> array:<br />    res += i<br />  <span class="hljs-keyword">return</span> i</span></pre><p name="7e74" id="7e74" class="graf graf--p graf-after--pre">If we instead took the functional way to write it, it could look as below.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="e0f2" id="e0f2" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">array</span>):<br />  <span class="hljs-keyword">if</span> array == []:<br />    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br />  <span class="hljs-keyword">return</span> array[<span class="hljs-number">0</span>] + <span class="hljs-built_in">sum</span>(array[<span class="hljs-number">1</span>:])</span></pre><p name="d485" id="d485" class="graf graf--p graf-after--pre">Even though this looks like a simple change, it’s actually a fundamentally different solution. In the iterative version, if we were to try to put it in natural language, would basically say “Start with 0, add each element to the result, at the end of the array we will have all of them added to the result” while the second one would say “Empty array has a sum of 0, for any non-empty array, we can take the first element and the result of summing the rest, and just add those.</p><p name="90d5" id="90d5" class="graf graf--p graf-after--p">So, if we have a list of items [3, 2, 7, 6], the first algorithm would sum it as</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="scss" name="25ac" id="25ac" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">((((<span class="hljs-number">0</span> + <span class="hljs-number">3</span>) + <span class="hljs-number">2</span>) + <span class="hljs-number">7</span>) + <span class="hljs-number">6</span>)</span></pre><p name="ae27" id="ae27" class="graf graf--p graf-after--pre">Whereas the second algorithm would sum it as</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="scss" name="53b3" id="53b3" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">(<span class="hljs-number">3</span> + (<span class="hljs-number">2</span> + (<span class="hljs-number">7</span> + (<span class="hljs-number">6</span> + <span class="hljs-number">0</span>))))</span></pre><p name="44c9" id="44c9" class="graf graf--p graf-after--pre">The real difference between them is, the second one explicitly relies on <strong class="markup--strong markup--p-strong">optimal substructure property</strong>. It follows the statement that we can just add the current number with the sum of the rest and the sum of the current array. I believe this line of thinking, especially for memoization-based dynamic programming becomes very important.</p><p name="5da9" id="5da9" class="graf graf--p graf-after--p">The second property dynamic programming relies on is <strong class="markup--strong markup--p-strong">overlapping subproblems property</strong>. This property states that we do not use the results of the subproblems once, we do it many times, which means it makes sense to store those results and reuse them as needed. Let’s clarify further.</p><p name="7d56" id="7d56" class="graf graf--p graf-after--p">In the <code class="markup--code markup--p-code">sum</code> example, it doesn’t make sense to use dynamic programming, simply because each value is computed exactly once. So, what would be an case where we have <strong class="markup--strong markup--p-strong">overlapping subproblems</strong>? The canonical example is the fibonacci numbers.</p><p name="c969" id="c969" class="graf graf--p graf-after--p">We all know and love fibonacci numbers, <code class="markup--code markup--p-code">f(n) = f(n-1) + f(n-2)</code> . When we write the paranthesis based computation tree, we will see something very interesting.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="scss" name="aa4e" id="aa4e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-built_in">f</span>(<span class="hljs-number">5</span>) = <span class="hljs-built_in">f</span>(<span class="hljs-number">4</span>) + <span class="hljs-built_in">f</span>(<span class="hljs-number">3</span>)<br /><span class="hljs-built_in">f</span>(<span class="hljs-number">4</span>) = <span class="hljs-built_in">f</span>(<span class="hljs-number">3</span>) + <span class="hljs-built_in">f</span>(<span class="hljs-number">2</span>)<br /><span class="hljs-built_in">f</span>(<span class="hljs-number">3</span>) = <span class="hljs-built_in">f</span>(<span class="hljs-number">2</span>) + <span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>)<br /><span class="hljs-built_in">f</span>(<span class="hljs-number">2</span>) = <span class="hljs-number">1</span>, <span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span><br /><br /><span class="hljs-built_in">f</span>(<span class="hljs-number">5</span>) = (((<span class="hljs-number">1</span> + <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>) + (<span class="hljs-number">1</span> + <span class="hljs-number">1</span>))</span></pre><p name="36fb" id="36fb" class="graf graf--p graf-after--pre">One should realize that we compute f(3) = (1+1) twice, one for computing f(4), one for computing f(5). This is the <strong class="markup--strong markup--p-strong">overlapping subproblems property</strong>. When we are computing the same substructures repeatedly, and the substructures preserve the optimality, we can use dynamic programming.</p><h3 name="26bd" id="26bd" class="graf graf--h3 graf-after--p">Some Personal Insights</h3><p name="d521" id="d521" class="graf graf--p graf-after--h3">I think one particularly interesting/important realization I had in my own perspective to these problems is that the recursive paradigm for solving problems allows one to easily discover the overlapping subproblems. In my early years of working with algorithms problems, I would try to find ad hoc algorithms that could solve some cases I would come up with. Now, I start with small examples(recursion base cases), look for optimal substructures(recursive cases), look for overlapping substructures(function calls to be cached/memoized). I’ll apply this line of thinking for 3Sum problem.</p><h4 name="57d8" id="57d8" class="graf graf--h4 graf-after--p">3Sum</h4><p name="c04e" id="c04e" class="graf graf--p graf-after--h4"><strong class="markup--strong markup--p-strong">Problem Statement: </strong>Given an array and a number, return all triples that add up to the number.</p><p name="7851" id="7851" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Small examples: </strong>If I have an array with 3 elements, then all I can do is check if they are equal to the number. If I have an array of 4 elements, I can do 2 things. (1) I can just take the sum of the first 3 elements, or I can take the last element with any two elements from the first 3 elements.</p><p name="a126" id="a126" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Optimal Substructure: </strong>The small example gives me a perspective. For each element, there are two cases. Either the element is in the sum, or it is not. So, we look at 2 cases for each element; (1) Ask for the 3Sum of the rest of the array, (2) ask for all 2Sum’s of the rest of the array, check if adding my element to them results in the asked number.</p><p name="eb0c" id="eb0c" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Overlapping Substructure: </strong>As I would realize if I tried to compute a length-5 array, this solution requires me to recompute 2Sum’s for the array each time I want to compute a 3Sum. Let’s write it similar to Fibonacci numbers.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="4d5d" id="4d5d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">3<span class="hljs-built_in">sum</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>], <span class="hljs-number">6</span>) = 3<span class="hljs-built_in">sum</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], <span class="hljs-number">6</span>) ++ 2sums([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br />3<span class="hljs-built_in">sum</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], <span class="hljs-number">6</span>) = 3<span class="hljs-built_in">sum</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">6</span>) ++ 2sums([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br /><br />Whereas<br /><br />2sums([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]) = 2sums([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) * <span class="hljs-number">3</span></span></pre><p name="0089" id="0089" class="graf graf--p graf-after--pre">Instead of the actual functions, I have written the number of steps associated with each computation, but the realization should be that we are computing <code class="markup--code markup--p-code">2sums([1, 2, 3])</code> twice, one for computing <code class="markup--code markup--p-code">3sum([1, 2, 3, 4], 6)</code> and one for computing <code class="markup--code markup--p-code">2sums([1, 2, 3, 4])</code> , and in fact that’s a property of <code class="markup--code markup--p-code">2sums</code> . Any array that computes its 2sum always computes 2sums’s of all of its subsets.</p><p name="2019" id="2019" class="graf graf--p graf-after--p">Upon this realization, we will simply precompute 2sum and relieve ourselves of the responsibility of computing it every single time. Below is the actual code we would write for those who would like to test it by hand.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="85c5" id="85c5" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">def</span> <span class="hljs-title function_">two_sums</span>(<span class="hljs-params">arr: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>]]:<br />    <span class="hljs-string">&quot;&quot;&quot;<br />    Returns a dictionary of all the two sums in the array<br />    &quot;&quot;&quot;</span><br />    two_sum_dict = {}<br />    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(arr)):<br />        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i + <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(arr)):<br />            <span class="hljs-keyword">if</span> arr[i] + arr[j] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> two_sum_dict:<br />                two_sum_dict[arr[i] + arr[j]] = [(arr[i], arr[j])]<br />            <span class="hljs-keyword">else</span>:<br />                two_sum_dict[arr[i] + arr[j]].append((arr[i], arr[j]))<br />    <span class="hljs-keyword">return</span> two_sum_dict<br /><br /><span class="hljs-keyword">def</span> <span class="hljs-title function_">three_sum</span>(<span class="hljs-params">arr: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>], <span class="hljs-built_in">sum</span>: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>]:<br />    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) &lt; <span class="hljs-number">3</span>:<br />        <span class="hljs-keyword">return</span> []<br /><br />    <span class="hljs-comment"># Compute 3sum for the first part.</span><br />    c1 = three_sum(arr[:-<span class="hljs-number">1</span>], <span class="hljs-built_in">sum</span>)<br />    <br />    <span class="hljs-comment"># Compute 2sum for the first part</span><br />    two_sum = two_sums(arr[:-<span class="hljs-number">1</span>])<br /><br />    <span class="hljs-comment"># Check for all the pairs of numbers in the first part that conforms</span><br />    <span class="hljs-comment"># to the given sum. </span><br />    c2 = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> t: (t[<span class="hljs-number">0</span>], t[<span class="hljs-number">1</span>], arr[-<span class="hljs-number">1</span>]), two_sum.get(<span class="hljs-built_in">sum</span> - arr[-<span class="hljs-number">1</span>], [])))<br /><br />    <span class="hljs-comment"># Merge two solutions</span><br />    <span class="hljs-keyword">return</span> c1 + c2</span></pre><p name="40e8" id="40e8" class="graf graf--p graf-after--pre">The cached version is somewhat trickier and not as neat as the version I provide above.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="546e" id="546e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">def</span> <span class="hljs-title function_">three_sum_cached</span>(<span class="hljs-params">arr: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>], <span class="hljs-built_in">sum</span>: <span class="hljs-built_in">int</span>, two_sums: <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>]:<br />    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(arr) &lt; <span class="hljs-number">3</span>:<br />        <span class="hljs-keyword">return</span> []<br /><br />    <span class="hljs-comment"># Same function call with the original version</span><br />    c1 = three_sum_cached(arr[:-<span class="hljs-number">1</span>], <span class="hljs-built_in">sum</span>, two_sums)<br /><br />    <span class="hljs-comment"># Instead of the function call, we lookup from the precomputed dictionary</span><br />    matching_two_sums = two_sums.get(<span class="hljs-built_in">sum</span> - arr[-<span class="hljs-number">1</span>], [])<br /><br />    <span class="hljs-comment"># This is to prevent using the same number twice</span><br />    filtered_two_sums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> t: t[<span class="hljs-number">0</span>] != arr[-<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> t[<span class="hljs-number">1</span>] != arr[-<span class="hljs-number">1</span>], matching_two_sums))<br /><br />    c2 = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> t: (t[<span class="hljs-number">0</span>], t[<span class="hljs-number">1</span>], arr[-<span class="hljs-number">1</span>]), filtered_two_sums))<br />    <span class="hljs-comment"># This is to prevent using the same triplets twice.</span><br />    <span class="hljs-comment"># For example, we delete (1, 4, 3) and only leave (1, 3, 4)</span><br />    filtered_c2 = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> t: t[<span class="hljs-number">0</span>] &lt; t[<span class="hljs-number">1</span>] &lt; t[<span class="hljs-number">2</span>], c2))<br /><br />    <span class="hljs-keyword">return</span> c1 + filtered_c2</span></pre><p name="edc1" id="edc1" class="graf graf--p graf-after--pre">The second algorithm is somewhat crude, but that’s probably on me. I bet there are better ways of implementing the caching.</p><p name="fa23" id="fa23" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Complexity: O(n²)(The time to compute the 2sums)</strong></p><p name="adbf" id="adbf" class="graf graf--p graf-after--p">Visually, while the original looks similar to this:</p><figure name="6e24" id="6e24" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*uPxMi97vZ0vYqjGNHOTcFw.png" data-width="4707" data-height="2304" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*uPxMi97vZ0vYqjGNHOTcFw.png"></figure><p name="48b1" id="48b1" class="graf graf--p graf-after--figure">The cached implementation is similar to this:</p><figure name="8a66" id="8a66" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*V92DTDFgYacxG3fP0Le-TQ.png" data-width="4527" data-height="2221" src="https://cdn-images-1.medium.com/max/800/1*V92DTDFgYacxG3fP0Le-TQ.png"></figure><p name="166a" id="166a" class="graf graf--p graf-after--figure">2Sum part is kind of cheating as I’ve not written that part of the algorithm recursively, so it’s more similar to this:</p><figure name="3430" id="3430" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Xhsmpc1uswA_Mn5ifl8trw.png" data-width="5439" data-height="2679" src="https://cdn-images-1.medium.com/max/800/1*Xhsmpc1uswA_Mn5ifl8trw.png"></figure><p name="1f6c" id="1f6c" class="graf graf--p graf-after--figure">Where 2Sums is the data structure that allows querying for tuples for a given amount in constant time.</p><h3 name="354e" id="354e" class="graf graf--h3 graf-after--p">Conclusion</h3><p name="e4ca" id="e4ca" class="graf graf--p graf-after--h3 graf--trailing">In this article, I tried to convey my method/perspective on solving algorithmic problems using dynamic programming. My methodology rests on first creating a naive recursive solution for a problem with optimal substructures, identifying overlapping substructures and caching/memoizing those function calls. Hope it’s useful!</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@alpkeles99" class="p-author h-card">Alperen Keleş</a> on <a href="https://medium.com/p/f520a5b2ba4b"><time class="dt-published" datetime="2023-06-07T04:47:12.361Z">June 7, 2023</time></a>.</p><p><a href="https://medium.com/@alpkeles99/learners-guide-to-dynamic-programming-1-f520a5b2ba4b" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on March 27, 2024.</p></footer></article></body></html>