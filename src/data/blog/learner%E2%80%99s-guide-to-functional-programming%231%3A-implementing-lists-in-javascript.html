<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Learner’s Guide to Functional Programming#1: Implementing Lists in JavaScript</title></head><body><article class="h-entry">

<section data-field="body" class="e-content">
<section name="3833" class="section section--body section--first section--last"><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="b3ab" id="b3ab" class="graf graf--h3 graf--leading graf--title">Learner’s Guide to Functional Programming#1: Implementing Lists in JavaScript</h3><p name="e891" id="e891" class="graf graf--p graf-after--h3">Although this article was written first, I suggest you read the prequel I read as background. Leaving the link below.</p><div name="a9d6" id="a9d6" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://alpkeles99.medium.com/learners-guide-to-functional-programming-0-sum-types-booleans-and-naturals-in-javascript-d20a44ca808d" data-href="https://alpkeles99.medium.com/learners-guide-to-functional-programming-0-sum-types-booleans-and-naturals-in-javascript-d20a44ca808d" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://alpkeles99.medium.com/learners-guide-to-functional-programming-0-sum-types-booleans-and-naturals-in-javascript-d20a44ca808d"><strong class="markup--strong markup--mixtapeEmbed-strong">Learner’s Guide to Functional Programming#0: Sum Types, Booleans and Naturals in Javascript</strong><br>alpkeles99.medium.com</a><a href="https://alpkeles99.medium.com/learners-guide-to-functional-programming-0-sum-types-booleans-and-naturals-in-javascript-d20a44ca808d" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="66a0a05c561ba009445d72b82cfbdb7c" data-thumbnail-img-id="1*rNub9K1VtRelmSjPVlWmvg.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*rNub9K1VtRelmSjPVlWmvg.png);"></a></div><p name="f91c" id="f91c" class="graf graf--p graf-after--mixtapeEmbed">There are many articles introducing functional programming. They mention immutability, first class functions, purity, recursion, and many other concepts with usually small examples of each one of them. In this series, I want to try a different way. We will implement functional data structures within using a very minimal subset of Javascript. No loops, no mutable variables, no builtins except primitive types.</p><p name="5571" id="5571" class="graf graf--p graf-after--p">The first of these data structures is a list. A list is a very simple data structure, below is a simple definition of a list type in typescript.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="typescript" name="c870" id="c870" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">type</span> <span class="hljs-title class_">List</span> = { <span class="hljs-attr">variant</span>: <span class="hljs-string">&quot;nil&quot;</span> } | { <span class="hljs-attr">variant</span>: <span class="hljs-string">&quot;cons&quot;</span>, <span class="hljs-attr">elem</span>: <span class="hljs-built_in">any</span>, <span class="hljs-attr">rest</span>: <span class="hljs-title class_">List</span> }</span></pre><p name="5dd3" id="5dd3" class="graf graf--p graf-after--pre">Here, we either have a “nil” variant with no elements, and a “cons” variant with a en element, as well as the rest of the list. Before going into implementation details, let’s imagine how would such a list look like.</p><figure name="1350" id="1350" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*irBBs3TmC-b_qyHBu179qw.png" data-width="3415" data-height="1993" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*irBBs3TmC-b_qyHBu179qw.png"><figcaption class="imageCaption">Three lists with lengths 0, 1, and 2.</figcaption></figure><p name="f326" id="f326" class="graf graf--p graf-after--figure">Below are the same definitions in Javascript code.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="javascript" name="0e6d" id="0e6d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">const</span> emptyList = { <span class="hljs-attr">variant</span>: <span class="hljs-string">&quot;nil&quot;</span> }; \\ []<br /><span class="hljs-keyword">const</span> singleElemList = { <span class="hljs-attr">variant</span>: <span class="hljs-string">&quot;cons&quot;</span>, <span class="hljs-attr">elem</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">rest</span>: emptyList } \\ [<span class="hljs-number">1</span>]<br /><span class="hljs-keyword">const</span> twoElemList = {<br />  { <span class="hljs-attr">variant</span>: <span class="hljs-string">&quot;cons&quot;</span>, <span class="hljs-attr">elem</span>: <span class="hljs-number">1</span>,<br />  <span class="hljs-attr">rest</span>: { <span class="hljs-attr">variant</span>: <span class="hljs-string">&quot;cons&quot;</span>, <span class="hljs-attr">elem</span>: <span class="hljs-number">2</span>, <br />  <span class="hljs-attr">rest</span>: emptyList }<br />} <span class="hljs-comment">// [1, 2]</span></span></pre><p name="caac" id="caac" class="graf graf--p graf-after--pre">We start from the first element with a <code class="markup--code markup--p-code">variant: &quot;cons&quot;</code> node, end we denote the end with a <code class="markup--code markup--p-code">variant: &quot;nil&quot;</code> node.</p><p name="d57c" id="d57c" class="graf graf--p graf-after--p">Here, we will have two constructors, one per variant.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="javascript" name="3d5e" id="3d5e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">const</span> <span class="hljs-title function_">mkEmpty</span> = (<span class="hljs-params"></span>) =&gt; (<br />    {<br />        <span class="hljs-attr">variant</span>: <span class="hljs-string">&quot;nil&quot;</span><br />    }<br />)<br /><br /><span class="hljs-keyword">const</span> <span class="hljs-title function_">mkList</span> = (<span class="hljs-params">elem, rest</span>) =&gt; (<br />    {<br />        <span class="hljs-attr">variant</span>: <span class="hljs-string">&quot;cons&quot;</span>,<br />        <span class="hljs-attr">elem</span>: elem,<br />        <span class="hljs-attr">rest</span>: rest<br />    }<br />)</span></pre><p name="2481" id="2481" class="graf graf--p graf-after--pre">If we want to make a list of only one item, we could easily compose them.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="javascript" name="10be" id="10be" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">const</span> <span class="hljs-title function_">mkListFromElem</span> = (<span class="hljs-params">elem</span>) =&gt; (<br />    <span class="hljs-title function_">mkList</span>(elem, <span class="hljs-title function_">mkEmpty</span>())<br />)</span></pre><p name="a0bb" id="a0bb" class="graf graf--p graf-after--pre">Implementing accessors is pretty straightforward.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="javascript" name="cde2" id="cde2" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">const</span> <span class="hljs-title function_">isEmpty</span> = (<span class="hljs-params">list</span>) =&gt; (<br />    list.<span class="hljs-property">variant</span> === <span class="hljs-string">&quot;nil&quot;</span><br />)<br /><br /><br /><span class="hljs-comment">// Below, we introduce the list notation. &quot;:&quot; is the prepending operation.</span><br /><span class="hljs-comment">// (elem : rest) -&gt; elem</span><br /><span class="hljs-comment">// Get first element</span><br /><span class="hljs-keyword">const</span> <span class="hljs-title function_">head</span> = (<span class="hljs-params">list</span>) =&gt; (<br />    list.<span class="hljs-property">elem</span><br />)<br /><br /><span class="hljs-comment">// Get the rest of the list</span><br /><span class="hljs-comment">// (elem : rest) -&gt; rest</span><br /><span class="hljs-keyword">const</span> <span class="hljs-title function_">tail</span> = (<span class="hljs-params">list</span>) =&gt; (<br />    list.<span class="hljs-property">rest</span><br />)</span></pre><p name="332c" id="332c" class="graf graf--p graf-after--pre">As we now have the basic building blocks at hand, we can start defining more complicated functions. The first is the length function.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="javascript" name="a6c5" id="a6c5" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment">// length(elem:rest) = 1 + length(rest)</span><br /><span class="hljs-keyword">const</span> <span class="hljs-title function_">length</span> = (<span class="hljs-params">list</span>) =&gt; (<br />    <span class="hljs-title function_">isEmpty</span>(list) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span> + <span class="hljs-title function_">length</span>(<span class="hljs-title function_">tail</span>(list))<br />)</span></pre><p name="91cb" id="91cb" class="graf graf--p graf-after--pre">The definition goes, is you have an empty list, that list has 0 length. For any other list, you can add one to the length of the rest of the list and return that.</p><p name="f333" id="f333" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">length(list) = length([list.head]) + length([list.rest])</code> is the relation we are using for this function.</p><p name="4096" id="4096" class="graf graf--p graf-after--p">Although we could continue implementing functions in ad hoc manners, now I will introduce you with Higher Order Functions map, filter and reduce. We will then use these functions as building blocks of more complex functions.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="javascript" name="fe98" id="fe98" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">const</span> <span class="hljs-title function_">map</span> = (<span class="hljs-params">list, f</span>) =&gt; (<br />    <span class="hljs-title function_">isEmpty</span>(list) ? <span class="hljs-title function_">mkEmpty</span>() : <span class="hljs-title function_">mkList</span>(<span class="hljs-title function_">f</span>(<span class="hljs-title function_">head</span>(list)), <span class="hljs-title function_">map</span>(<span class="hljs-title function_">tail</span>(list), f))<br />)</span></pre><p name="c5c8" id="c5c8" class="graf graf--p graf-after--pre">Map function applies a function <code class="markup--code markup--p-code">f</code> to all elements of a list. You can see that we are effectively recreating the list by computing <code class="markup--code markup--p-code">f</code> on <code class="markup--code markup--p-code">head(list)</code> and passing it to the <code class="markup--code markup--p-code">map(tail(list), f)</code> .</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="javascript" name="2092" id="2092" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">const</span> <span class="hljs-title function_">filter</span> = (<span class="hljs-params">list, p</span>) =&gt; (<br />    <span class="hljs-title function_">isEmpty</span>(list) ?<br />        <span class="hljs-title function_">mkEmpty</span>()<br />        : <span class="hljs-title function_">f</span>(<span class="hljs-title function_">head</span>(list)) ?<br />            <span class="hljs-title function_">mkList</span>(<span class="hljs-title function_">head</span>(list), <span class="hljs-title function_">filter</span>(<span class="hljs-title function_">tail</span>(list), p))<br />            : <span class="hljs-title function_">filter</span>(<span class="hljs-title function_">tail</span>(list), p)<br />)</span></pre><p name="98f7" id="98f7" class="graf graf--p graf-after--pre">Filter takes a list, and a predicate <code class="markup--code markup--p-code">p</code>, a predicate is a type of function that returns a boolean. Filters create a list with the elements passing the predicate.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="javascript" name="00ad" id="00ad" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">const</span> <span class="hljs-title function_">reduce</span> = (<span class="hljs-params">list, f, acc</span>) =&gt; (<br />    <span class="hljs-title function_">isEmpty</span>(list) ? acc : <span class="hljs-title function_">reduce</span>(<span class="hljs-title function_">tail</span>(list), f, <span class="hljs-title function_">f</span>(acc, <span class="hljs-title function_">head</span>(list)))<br />)</span></pre><p name="5399" id="5399" class="graf graf--p graf-after--pre">Reduce is the last one of our building blocks. We use reduce to apply functions over the list by propagating the result. I usually find reduce the most confusing among these three, so let’s use reduce for some functions in order to allow a more comprehensive understanding.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="javascript" name="ec40" id="ec40" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment">// Instead of recursively calling tail ourselves, we call reduce</span><br /><span class="hljs-comment">// with the initial value of 0, incremented for every node.</span><br /><span class="hljs-keyword">const</span> <span class="hljs-title function_">lenReduce</span> = (<span class="hljs-params">list, f</span>) =&gt; (<br />    <span class="hljs-title function_">reduce</span>(list, <span class="hljs-function">(<span class="hljs-params">acc, elem</span>) =&gt;</span> acc + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)<br />)<br /><br /><span class="hljs-comment">// Reverse initiates an empty list. At every point, we take the</span><br /><span class="hljs-comment">// head, prepend it to the accumulator.</span><br /><span class="hljs-keyword">const</span> <span class="hljs-title function_">reverse</span> = (<span class="hljs-params">list</span>) =&gt; (<br />    <span class="hljs-title function_">reduce</span>(list, <span class="hljs-function">(<span class="hljs-params">acc, elem</span>) =&gt;</span> <span class="hljs-title function_">mkList</span>(elem, acc), <span class="hljs-title function_">mkEmpty</span>())<br />)</span></pre><p name="4861" id="4861" class="graf graf--p graf-after--pre">Another important building block is <code class="markup--code markup--p-code">concat</code> which allows us two concatenate two lists.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="javascript" name="1936" id="1936" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment">// We will use ++ for concat notation.</span><br /><span class="hljs-comment">// concat(l1, l2) = l1 ++ l2</span><br /><br /><span class="hljs-comment">// If the first list is empty, we can just return the second list.</span><br /><span class="hljs-comment">// Otherwise, we concatenate the rest of the list with and prepend</span><br /><span class="hljs-comment">// the first element of the first list.</span><br /><span class="hljs-keyword">const</span> <span class="hljs-title function_">concat</span> = (<span class="hljs-params">list1, list2</span>) =&gt; (<br />    <span class="hljs-title function_">isEmpty</span>(list1) ? <br />        list2 <br />        : <span class="hljs-title function_">mkList</span>(<span class="hljs-title function_">head</span>(list1), <span class="hljs-title function_">concat</span>(<span class="hljs-title function_">tail</span>(list1), list2))<br />)</span></pre><p name="b92c" id="b92c" class="graf graf--p graf-after--pre">As we have <code class="markup--code markup--p-code">concat</code> we can now define prepend and append.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="javascript" name="2a8f" id="2a8f" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><br /><span class="hljs-comment">// prepend(list, elem) = (elem : list)</span><br /><span class="hljs-keyword">const</span> <span class="hljs-title function_">prepend</span> = (<span class="hljs-params">list, elem</span>) =&gt; (<br />    <span class="hljs-title function_">mkList</span>(elem, list)<br />)<br /><br /><span class="hljs-comment">// append(list, elem) = list ++ [elem]</span><br /><span class="hljs-keyword">const</span> <span class="hljs-title function_">append</span> = (<span class="hljs-params">list, elem</span>) =&gt; (<br />    <span class="hljs-title function_">concat</span>(list, <span class="hljs-title function_">mkListFromElem</span>(elem))<br />)</span></pre><p name="2777" id="2777" class="graf graf--p graf-after--pre">As you see, prepend is the same as <code class="markup--code markup--p-code">mkList</code> and <code class="markup--code markup--p-code">append</code> is equivalent to creating a one element list and concatenating it to the end.</p><p name="89fe" id="89fe" class="graf graf--p graf-after--p">The last function we are implementing is the indexing function. Here, we pass the index parameter <code class="markup--code markup--p-code">n</code> and we decrease it as we move within the list.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="javascript" name="60e6" id="60e6" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment">// nth((elem:rest), n) = nth(rest, n - 1)</span><br /><span class="hljs-keyword">const</span> <span class="hljs-title function_">nth</span> = (<span class="hljs-params">list, n</span>) =&gt; (<br />    n === <span class="hljs-number">0</span> ? <span class="hljs-title function_">head</span>(list) : <span class="hljs-title function_">nth</span>(<span class="hljs-title function_">tail</span>(list), n - <span class="hljs-number">1</span>)<br />)</span></pre><p name="5d7e" id="5d7e" class="graf graf--p graf-after--pre">Below is the Github repository for the functions introduced within this article.</p><div name="3d91" id="3d91" class="graf graf--mixtapeEmbed graf-after--p graf--trailing"><a href="https://github.com/alpaylan/functional-ts/blob/main/List.ts" data-href="https://github.com/alpaylan/functional-ts/blob/main/List.ts" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://github.com/alpaylan/functional-ts/blob/main/List.ts"><strong class="markup--strong markup--mixtapeEmbed-strong">functional-ts/List.ts at main · alpaylan/functional-ts</strong><br><em class="markup--em markup--mixtapeEmbed-em">Functional Data Structures in Typescript. Contribute to alpaylan/functional-ts development by creating an account on…</em>github.com</a><a href="https://github.com/alpaylan/functional-ts/blob/main/List.ts" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="92f0723e5e9c5b92ed81aaf8cfac6ad1" data-thumbnail-img-id="0*Y2YP655OJeXvwVdi" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*Y2YP655OJeXvwVdi);"></a></div></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@alpkeles99" class="p-author h-card">Alperen Keleş</a> on <a href="https://medium.com/p/8ec3946aa9ab"><time class="dt-published" datetime="2023-07-12T04:45:40.430Z">July 12, 2023</time></a>.</p><p><a href="https://medium.com/@alpkeles99/learners-guide-to-functional-programming-1-implementing-lists-in-javascript-8ec3946aa9ab" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on March 27, 2024.</p></footer></article></body></html>