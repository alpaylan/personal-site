<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Learner’s Guide to Functional Programming#0: Sum Types, Booleans and Naturals in Javascript</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Learner’s Guide to Functional Programming#0: Sum Types, Booleans and Naturals in Javascript</h1>
</header>
<section data-field="body" class="e-content">
<section name="6b59" class="section section--body section--first section--last"><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="1ad2" id="1ad2" class="graf graf--h3 graf--leading graf--title">Learner’s Guide to Functional Programming#0: Sum Types, Booleans and Naturals in Javascript</h3><p name="0542" id="0542" class="graf graf--p graf-after--h3">After writing the first article of the Learner’s Guide to Functional Programming series yesterday on implementing functional lists, I have realized I may have jumped in too fast. Hence, I decided to move one step back and start by introducing Sum Types, and building Booleans and Naturals using them. We have already implicitly introduced them in the previous article, but this article will make it explicit and clear.</p><div name="aa15" id="aa15" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://alpkeles99.medium.com/learners-guide-to-functional-programming-1-implementing-lists-in-javascript-8ec3946aa9ab" data-href="https://alpkeles99.medium.com/learners-guide-to-functional-programming-1-implementing-lists-in-javascript-8ec3946aa9ab" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://alpkeles99.medium.com/learners-guide-to-functional-programming-1-implementing-lists-in-javascript-8ec3946aa9ab"><strong class="markup--strong markup--mixtapeEmbed-strong">Learner’s Guide to Functional Programming#1: Implementing Lists in JavaScript</strong><br><em class="markup--em markup--mixtapeEmbed-em">There are many articles introducing functional programming. They mention immutability, first class functions, purity…</em>alpkeles99.medium.com</a><a href="https://alpkeles99.medium.com/learners-guide-to-functional-programming-1-implementing-lists-in-javascript-8ec3946aa9ab" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="e428410e45424181d51864a32a09bd41" data-thumbnail-img-id="1*irBBs3TmC-b_qyHBu179qw.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*irBBs3TmC-b_qyHBu179qw.png);"></a></div><p name="d369" id="d369" class="graf graf--p graf-after--mixtapeEmbed">Below is the definition from <a href="https://en.wikipedia.org/wiki/Tagged_union" data-href="https://en.wikipedia.org/wiki/Tagged_union" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Wikipedia.</a></p><blockquote name="b31f" id="b31f" class="graf graf--blockquote graf-after--p">In <a href="https://en.wikipedia.org/wiki/Computer_science" data-href="https://en.wikipedia.org/wiki/Computer_science" class="markup--anchor markup--blockquote-anchor" title="Computer science" rel="noopener" target="_blank">computer science</a>, a <strong class="markup--strong markup--blockquote-strong">tagged union</strong>, also called a <strong class="markup--strong markup--blockquote-strong">variant</strong>, <strong class="markup--strong markup--blockquote-strong">variant record</strong>, <strong class="markup--strong markup--blockquote-strong">choice type</strong>, <strong class="markup--strong markup--blockquote-strong">discriminated union</strong>, <a href="https://en.wikipedia.org/wiki/Disjoint_union" data-href="https://en.wikipedia.org/wiki/Disjoint_union" class="markup--anchor markup--blockquote-anchor" title="Disjoint union" rel="noopener" target="_blank"><strong class="markup--strong markup--blockquote-strong">disjoint union</strong></a>, <strong class="markup--strong markup--blockquote-strong">sum type </strong>or <a href="https://en.wikipedia.org/wiki/Coproduct" data-href="https://en.wikipedia.org/wiki/Coproduct" class="markup--anchor markup--blockquote-anchor" title="Coproduct" rel="noopener" target="_blank"><strong class="markup--strong markup--blockquote-strong">coproduct</strong></a>, is a <a href="https://en.wikipedia.org/wiki/Data_structure" data-href="https://en.wikipedia.org/wiki/Data_structure" class="markup--anchor markup--blockquote-anchor" title="Data structure" rel="noopener" target="_blank">data structure</a> used to hold a value that could take on several different, but fixed, types. Only one of the types can be in use at any one time, and a <strong class="markup--strong markup--blockquote-strong">tag</strong> field explicitly indicates which one is in use. It can be thought of as a type that has several “cases”, each of which should be handled correctly when that type is manipulated.</blockquote><p name="852a" id="852a" class="graf graf--p graf-after--blockquote">So, the rules are simple. We have several <strong class="markup--strong markup--p-strong">variants </strong>denoted with different tags. You may remember we had the following definition for the List type in the first article.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="typescript" name="2e56" id="2e56" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">type</span> <span class="hljs-title class_">List</span> = { <span class="hljs-attr">variant</span>: <span class="hljs-string">&quot;nil&quot;</span> } | { <span class="hljs-attr">variant</span>: <span class="hljs-string">&quot;cons&quot;</span>, <span class="hljs-attr">elem</span>: <span class="hljs-built_in">any</span>, <span class="hljs-attr">rest</span>: <span class="hljs-title class_">List</span> }</span></pre><p name="aeda" id="aeda" class="graf graf--p graf-after--pre">Let’s forget about that for now and focus on a simpler example, <strong class="markup--strong markup--p-strong">booleans</strong>. Booleans have two values, true and false, each one can be defined with a variant. Below is the typescript definition for boolean.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="typescript" name="bb3e" id="bb3e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Boolean</span> = { <span class="hljs-attr">variant</span>: <span class="hljs-string">&quot;True&quot;</span> } | { <span class="hljs-attr">variant</span>: <span class="hljs-string">&quot;False&quot;</span> }</span></pre><figure name="1347" id="1347" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*dXVZFk7BAToviM1VAV0Xcw.png" data-width="2694" data-height="2019" src="https://cdn-images-1.medium.com/max/800/1*dXVZFk7BAToviM1VAV0Xcw.png"><figcaption class="imageCaption">Visual Representation of Bool Variants</figcaption></figure><p name="a956" id="a956" class="graf graf--p graf-after--figure">These variants do not hold any extra information in addition to their tags. Using only tag-checks, we can implement classical logic operators <strong class="markup--strong markup--p-strong">not, and, or, xor </strong>as shown below.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="cpp" name="e043" id="e043" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-type">const</span> True = () =&gt; ({ variant: <span class="hljs-string">&quot;True&quot;</span> });<br /><span class="hljs-type">const</span> False = () =&gt; ({ variant: <span class="hljs-string">&quot;False&quot;</span> });<br /><br /><span class="hljs-type">const</span> <span class="hljs-keyword">not</span> = (b) =&gt; (<br />    b.variant === <span class="hljs-string">&quot;True&quot;</span> ? <span class="hljs-built_in">False</span>() : <span class="hljs-built_in">True</span>()<br />)<br /><br /><span class="hljs-type">const</span> <span class="hljs-keyword">and</span> = (b1, b2) =&gt; (<br />    b1.variant === <span class="hljs-string">&quot;True&quot;</span> ? b2 : <span class="hljs-built_in">False</span>()<br />)<br /><br /><span class="hljs-type">const</span> <span class="hljs-keyword">or</span> = (b1, b2) =&gt; (<br />    b1.variant === <span class="hljs-string">&quot;True&quot;</span> ? <span class="hljs-built_in">True</span>() : b2<br />)<br /><br /><span class="hljs-type">const</span> <span class="hljs-keyword">xor</span> = (b1, b2) =&gt; (<br />    b1.variant === <span class="hljs-string">&quot;True&quot;</span> ? <span class="hljs-built_in">not</span>(b2) : b2<br />)</span></pre><p name="9636" id="9636" class="graf graf--p graf-after--pre">You may realize I am kind of cheating here. I am using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_operator" data-href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_operator" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">if-expressions</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Strict_equality" data-href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Strict_equality" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">strict equality</a> for checking variants. I do this because in JavaScript land, I don’t have any kind of primitive expression for <a href="https://en.wikipedia.org/wiki/Pattern_matching" data-href="https://en.wikipedia.org/wiki/Pattern_matching" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">pattern matching</a> on types as other more functional languages such as OCaml, Haskell, Racket or Rust have.</p><p name="fe1d" id="fe1d" class="graf graf--p graf-after--p">Our little library on the other hand is very useful at this point, we can compute any valid logical formula in <a href="https://en.wikipedia.org/wiki/Classical_logic" data-href="https://en.wikipedia.org/wiki/Classical_logic" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">classical logic</a> with these 6 functions we have.</p><p name="bd55" id="bd55" class="graf graf--p graf-after--p">Another useful operator on booleans is If-Then-Else expression as we have already seen. We can implement is as below.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="typescript" name="0865" id="0865" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">const</span> <span class="hljs-title function_">ifThenElse</span> = (<span class="hljs-params">b, t, e</span>) =&gt; (<br />    b.<span class="hljs-property">variant</span> === <span class="hljs-string">&quot;True&quot;</span> ? t : e<br />)</span></pre><p name="a48d" id="a48d" class="graf graf--p graf-after--pre">This expression will return <code class="markup--code markup--p-code">t</code> if <code class="markup--code markup--p-code">b</code> is True, else <code class="markup--code markup--p-code">e</code> , same way with the if-expression we have been using.</p><p name="f0c4" id="f0c4" class="graf graf--p graf-after--p">You may have realized booleans are kind of boring. They are very simple, for the very reason I talked at the beginning, none of the variants have any type of data. Let’s stir things up a bit with natural numbers.</p><h3 name="bc25" id="bc25" class="graf graf--h3 graf-after--p">Peano Arithmetic</h3><p name="16a6" id="16a6" class="graf graf--p graf-after--h3">So, coming from the mainstream imperative programming side, we tend to take primitive types for granted. Booleans, integers, strings are just given to us, we usually don’t have to work for them. That’s why I was very surprised and excited when one of our first tasks was to encode and implement functions on natural numbers as part of a functional programming class. This encoding is called <a href="https://wiki.haskell.org/Peano_numbers#:~:text=Peano%20numbers%20are%20a%20simple,arithmetic%20due%20to%20their%20simplicity." data-href="https://wiki.haskell.org/Peano_numbers#:~:text=Peano%20numbers%20are%20a%20simple,arithmetic%20due%20to%20their%20simplicity." class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">Peano Numbers</strong></a>. Let’s see if I can get you excited about them like me.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="typescript" name="fdee" id="fdee" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Nat</span> = { <span class="hljs-attr">variant</span>: <span class="hljs-string">&quot;O&quot;</span> } | { <span class="hljs-attr">variant</span>: <span class="hljs-string">&quot;S&quot;</span>, <span class="hljs-attr">n</span>: <span class="hljs-title class_">Nat</span> }</span></pre><p name="c153" id="c153" class="graf graf--p graf-after--pre">We have two variants, the first one is <strong class="markup--strong markup--p-strong">“O” </strong>that represents 0, and the second one is <strong class="markup--strong markup--p-strong">“S”, also short for successor, </strong>that represents <strong class="markup--strong markup--p-strong">n+1 </strong>for some number <strong class="markup--strong markup--p-strong">n.</strong> So, let’s have the constructors for each variant.</p><figure name="b09a" id="b09a" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*rNub9K1VtRelmSjPVlWmvg.png" data-width="4124" data-height="754" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*rNub9K1VtRelmSjPVlWmvg.png"><figcaption class="imageCaption">Visual Representation of Nat Variants</figcaption></figure><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="typescript" name="7acc" id="7acc" class="graf graf--pre graf-after--figure graf--preV2"><span class="pre--content"><span class="hljs-keyword">const</span> <span class="hljs-title function_">O</span> = (<span class="hljs-params"></span>) =&gt; ({ <span class="hljs-attr">variant</span>: <span class="hljs-string">&quot;O&quot;</span> });<br /><span class="hljs-keyword">const</span> <span class="hljs-title function_">S</span> = (<span class="hljs-params">n</span>) =&gt; ({ <span class="hljs-attr">variant</span>: <span class="hljs-string">&quot;S&quot;</span>, <span class="hljs-attr">succ</span>: n });</span></pre><p name="8286" id="8286" class="graf graf--p graf-after--pre">These functions allow us to express all naturals starting from 0.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="scss" name="7f5a" id="7f5a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-number">0</span>: <span class="hljs-built_in">O</span>()<br /><span class="hljs-number">1</span>: <span class="hljs-built_in">S</span>(<span class="hljs-built_in">O</span>())<br /><span class="hljs-number">2</span>: <span class="hljs-built_in">S</span>(<span class="hljs-built_in">S</span>(<span class="hljs-built_in">O</span>())</span></pre><p name="7d08" id="7d08" class="graf graf--p graf-after--pre">In simpler terms, the number of nested <strong class="markup--strong markup--p-strong">S </strong>calls correspond to our natural number.</p><p name="b149" id="b149" class="graf graf--p graf-after--p">Okay, we can have numbers, but can we do useful operations with them? Indeed we can, let’s look at our operators.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="typescript" name="9564" id="9564" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment">// Checking if we have 0 or some successor.</span><br /><span class="hljs-keyword">const</span> <span class="hljs-title function_">isZero</span> = (<span class="hljs-params">n</span>) =&gt; (<br />    n.<span class="hljs-property">variant</span> === <span class="hljs-string">&quot;O&quot;</span><br />)<br /><br /><span class="hljs-comment">// As we are talking about naturals, the lowest number is 0, </span><br /><span class="hljs-comment">// so predecessor of 0 is also 0. For S variant, we just look</span><br /><span class="hljs-comment">// what the number is successor of.</span><br /><span class="hljs-comment">// We have the relation succ(n) = pred(n+1)</span><br /><span class="hljs-keyword">const</span> <span class="hljs-title function_">pred</span> = (<span class="hljs-params">n</span>) =&gt; (<br />    <span class="hljs-title function_">isZero</span>(n) ? n : n.<span class="hljs-property">succ</span><br />)<br /><br /><br /><span class="hljs-comment">// We combines the facts that n + m = (n - 1) + (m + 1)</span><br /><span class="hljs-comment">// and 0 + m = m. We decrease n as we increase m until n = 0.</span><br /><span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">n, m</span>) =&gt; (<br />    <span class="hljs-title function_">isZero</span>(n) ? m : <span class="hljs-title function_">add</span>(<span class="hljs-title function_">pred</span>(n), <span class="hljs-title function_">S</span>(m))<br />)<br /><br /><span class="hljs-comment">// We combine the facts that n - m = (n - 1) - (m - 1)</span><br /><span class="hljs-comment">// and n - 0 = n. We decrease both numbers until m is 0.</span><br /><span class="hljs-keyword">const</span> <span class="hljs-title function_">sub</span> = (<span class="hljs-params">n, m</span>) =&gt; (<br />    <span class="hljs-title function_">isZero</span>(m) ? n : <span class="hljs-title function_">sub</span>(<span class="hljs-title function_">pred</span>(n), <span class="hljs-title function_">pred</span>(m))<br />)<br /><br /><span class="hljs-comment">// We combine the facts that n * m = m + (n-1) * m</span><br /><span class="hljs-comment">// and 0 * n = 0. We decrease n until n = 0.</span><br /><span class="hljs-keyword">const</span> <span class="hljs-title function_">mul</span> = (<span class="hljs-params">n, m</span>) =&gt; (<br />    <span class="hljs-title function_">isZero</span>(n) ? <span class="hljs-title function_">O</span>() : <span class="hljs-title function_">add</span>(m, <span class="hljs-title function_">mul</span>(<span class="hljs-title function_">pred</span>(n), m))<br />)</span></pre><p name="7c64" id="7c64" class="graf graf--p graf-after--pre">If you are careful, you might have realized the rather hidden recursive structure here. We almost always use the <strong class="markup--strong markup--p-strong">O </strong>variant as our base case, and we recurse over <strong class="markup--strong markup--p-strong">S </strong>variant. In <strong class="markup--strong markup--p-strong">add, sub, </strong>and <strong class="markup--strong markup--p-strong">mul</strong>, we use two relations, one for our base case on <strong class="markup--strong markup--p-strong">O, </strong>and one for our recursive case <strong class="markup--strong markup--p-strong">S.</strong></p><p name="a335" id="a335" class="graf graf--p graf-after--p">Of course, without comparison operators, we couldn’t talk about numbers. Let’s add comparisons.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="typescript" name="faad" id="faad" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment">// Two numbers are equal in two cases.</span><br /><span class="hljs-comment">// 1. Both of them are equal to 0</span><br /><span class="hljs-comment">// 2. None of them are equal to 0, and their predecessors are equal</span><br /><span class="hljs-keyword">const</span> <span class="hljs-title function_">eq</span> = (<span class="hljs-params">n, m</span>) =&gt; (<br />    (<span class="hljs-title function_">isZero</span>(n) &amp;&amp; <span class="hljs-title function_">isZero</span>(m))<br />    || (!<span class="hljs-title function_">isZero</span>(n) &amp;&amp; !<span class="hljs-title function_">isZero</span>(m) &amp;&amp; <span class="hljs-title function_">eq</span>(<span class="hljs-title function_">pred</span>(n), <span class="hljs-title function_">pred</span>(m)))<br />)<br /><br /><span class="hljs-comment">// n is less than or equal to m in two cases.</span><br /><span class="hljs-comment">// 1. n is equal to 0</span><br /><span class="hljs-comment">// 2. m is not equal to 0, and (n - 1) &lt;= (m - 1)</span><br /><span class="hljs-keyword">const</span> <span class="hljs-title function_">lte</span> = (<span class="hljs-params">n, m</span>) =&gt; (<br />    <span class="hljs-title function_">isZero</span>(n) || (!<span class="hljs-title function_">isZero</span>(m) &amp;&amp; <span class="hljs-title function_">lte</span>(<span class="hljs-title function_">pred</span>(n), <span class="hljs-title function_">pred</span>(m)))<br />)<br /><br /><span class="hljs-comment">// n is less than m when</span><br /><span class="hljs-comment">// n != m, and n &lt;= m.</span><br /><span class="hljs-keyword">const</span> <span class="hljs-title function_">lt</span> = (<span class="hljs-params">n, m</span>) =&gt; (<br />    (!<span class="hljs-title function_">eq</span>(n, m)) &amp;&amp; <span class="hljs-title function_">lte</span>(n, m)<br />)<br /><br /><span class="hljs-comment">// For greater than, we just use the contrapositive relations.</span><br /><span class="hljs-keyword">const</span> <span class="hljs-title function_">gt</span> = (<span class="hljs-params">n, m</span>) =&gt; (<br />    !<span class="hljs-title function_">lte</span>(n, m)<br />)<br /><span class="hljs-comment">// For greater than or equals,</span><br /><span class="hljs-comment">// we just use the contrapositive relations.</span><br /><span class="hljs-keyword">const</span> <span class="hljs-title function_">gte</span> = (<span class="hljs-params">n, m</span>) =&gt; (<br />    !<span class="hljs-title function_">lt</span>(n, m)<br />)</span></pre><h3 name="d75e" id="d75e" class="graf graf--h3 graf-after--pre">Conclusion</h3><p name="80cb" id="80cb" class="graf graf--p graf-after--h3 graf--trailing">I am hoping that this article has shown the convenience of sum types(or tagged unions or discriminated unions, pick according to your taste) in expressing various types of data. I would suggest you read the first article on implementing lists again after reading this one. Lastly, I really hope it showed you that there are alternatives to our data models. Binary encoded integers are not the only possible encoding for numbers, as random access arrays are not the only encoding for lists. Every encoding has their own pros and cons, and explicitly thinking in terms of datatypes, variants, and encodings is very helpful in designing software models for real world.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@alpkeles99" class="p-author h-card">Alperen Keleş</a> on <a href="https://medium.com/p/d20a44ca808d"><time class="dt-published" datetime="2023-07-13T04:57:45.129Z">July 13, 2023</time></a>.</p><p><a href="https://medium.com/@alpkeles99/learners-guide-to-functional-programming-0-sum-types-booleans-and-naturals-in-javascript-d20a44ca808d" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on March 27, 2024.</p></footer></article></body></html>