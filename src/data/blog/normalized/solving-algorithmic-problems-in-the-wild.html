<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Solving Algorithmic Problems in The Wild</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Solving Algorithmic Problems in The Wild</h1>
</header>
<section data-field="subtitle" class="p-summary">
For most software engineers, algorithmic problems are this bizarre type of problems that they only have to know in order to succeed in…
</section>
<section data-field="body" class="e-content">
<section name="e446" class="section section--body section--first section--last"><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="373a" id="373a" class="graf graf--h3 graf--leading graf--title">Solving Algorithmic Problems in The Wild</h3><p name="a381" id="a381" class="graf graf--p graf-after--h3">For most software engineers, algorithmic problems are this bizarre type of problems that they only have to know in order to succeed in their interviews and get a job. Perhaps most readers will concede that they are sometimes useful, but I would imagine only a handful few studied solving algorithms outside of LeetCode or their college classes.</p><p name="516e" id="516e" class="graf graf--p graf-after--p">The premise of this article is that the methods for solving your Algorithms homework or LeetCode mediums are ill-equipped to handle the algorithmic problems you will face as a software engineer, and I hope to provide you with a fresh technique I myself employ. To be fair to the reader, the two examples I talk about in the article are far from any reasonable definition of <strong class="markup--strong markup--p-strong">the Wild, </strong>but let’s bear with me for now!</p><h3 name="d0ee" id="d0ee" class="graf graf--h3 graf-after--p">What is the problem with solving LeetCode?</h3><p name="4be1" id="4be1" class="graf graf--p graf-after--h3">The problem is not that solving LeetCode problems is bad, per se, but how the platform is designed in getting you to solve questions.</p><ol class="postList"><li name="0868" id="0868" class="graf graf--li graf-after--p">The set of inputs is fixed and limited. Our instincts urge us to submit the least good enough code that passes all the existing inputs without considering the problem in more depth.</li><li name="074f" id="074f" class="graf graf--li graf-after--li">The feedback from the platform is imminent, the number of tests passing, leading to the fact that we tend to ignore any other forms of possible feedback in terms of correctness and performance.</li></ol><p name="a64d" id="a64d" class="graf graf--p graf-after--li">You might have realized that the two points have nearly identical indications, we need to understand what the problem is asking and the algorithm we design in more detail than LeetCode forces or sets us to do.</p><p name="d411" id="d411" class="graf graf--p graf-after--p">Why? Because we don’t have such nice input-output examples in reality. The ones we have are called unit tests, which are impossible to write for any sufficiently complex algorithmic problem. Imagine you are implementing a new shortest path algorithm for graphs that has certain types of properties, how many graphs and input-output examples would you need to see to have a sufficiently solid belief on the correctness of your algorithm?</p><p name="64e7" id="64e7" class="graf graf--p graf-after--p">If unit tests are insufficient, what can we do then? Well, there is the classic computer science approach of picking a pen and paper, writing down the invariants of the algorithms and an inductive proof; or you could just find <a href="https://twitter.com/Keleesssss" data-href="https://twitter.com/Keleesssss" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">a friend doing a Ph.D. in formal verification</a> to write your proofs for you. For the rest of this article, I’ll work on convincing you that coming up with some properties for your problem and writing random tests in the style of <a href="https://en.wikipedia.org/wiki/QuickCheck" data-href="https://en.wikipedia.org/wiki/QuickCheck" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">QuickCheck</a> is a better option.</p><h3 name="5753" id="5753" class="graf graf--h3 graf-after--p">What the heck is a property?</h3><p name="7113" id="7113" class="graf graf--p graf-after--h3">A property is a weird thing. In tutorials for property-based testing, you usually see properties like this.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="cpp" name="f2de" id="f2de" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">list.<span class="hljs-built_in">reverse</span>().<span class="hljs-built_in">reverse</span>() == list<br /><span class="hljs-comment">// Reversing a list twice gives you the same list</span></span></pre><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="go" name="2b25" id="2b25" class="graf graf--pre graf-after--pre graf--preV2"><span class="pre--content">list.<span class="hljs-built_in">append</span>(x).<span class="hljs-built_in">len</span>() == list.<span class="hljs-built_in">len</span>() + <span class="hljs-number">1</span><br /><span class="hljs-comment">// Adding an item to a list increases its length by one</span></span></pre><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="scss" name="5224" id="5224" class="graf graf--pre graf-after--pre graf--preV2"><span class="pre--content"><span class="hljs-built_in">sorted</span>(list.sort())<br /><span class="hljs-comment">// Sorting a list means it&#x27;s sorted.</span></span></pre><p name="4a6d" id="4a6d" class="graf graf--p graf-after--pre">I’m sure these seem like no brainers to you, <em class="markup--em markup--p-em">what do you mean sorting a list means it’s sorted, what the hell was it gonna be?</em></p><p name="dce2" id="dce2" class="graf graf--p graf-after--p">The reality is different though. The <em class="markup--em markup--p-em">meaning </em>of the sorting function is that the output respects to some ordering <code class="markup--code markup--p-code">(sorted(list) == true)</code>. We have deeply embodied that meaning, so such examples are obvious, and might feel like a child’s toy. For algorithms, data structures, or code that is less studied, less familiar, it is possible that we never thought about the meaning of them.</p><p name="9ed8" id="9ed8" class="graf graf--p graf-after--p">What are other types of properties?(there are perhaps more formal/correct names for these, please notify me if so)</p><ul class="postList"><li name="db46" id="db46" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Modeling Property: </strong>The property that the results of our function is the same as another function. Perhaps we are writing a blazingly fast sorting function, and we want the result to be the same as the result of bubble sort.</li><li name="f088" id="f088" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">RoundTrip Property: </strong>Roundtrip properties are usually found in programs such as parsers or encoders. One example I previously used is <code class="markup--code markup--li-code">JSON.parse(JSON.stringify(object)) === object</code> . You can imagine we actually rely a lot on this property a lot while sending data over the wire.</li><li name="d7e4" id="d7e4" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Effect Properties: </strong>Effect properties build the expectation that the result of some computation is a (simple)function of the input. When we don’t care about the way a computation is performed, but rather the effect of the computation on some state/variable, we use effect properties. All 3 examples I gave in the beginning are effect properties.</li></ul><h3 name="ff68" id="ff68" class="graf graf--h3 graf-after--li">Where does properties and algorithmic problems come together?</h3><p name="d3fa" id="d3fa" class="graf graf--p graf-after--h3">As I said, LeetCode is all nice and good, but in reality, we have to define the correctness of our programs. Property-based tests with well-crafted properties provide more confidence in such correctness than unit tests. In the rest of the article, I will provide two examples of properties I came up with for my own problems.</p><p name="83b6" id="83b6" class="graf graf--p graf-after--p">The first problem I will talk about is a familiar one, it’s actually a LeetCode medium in addition to being an elementary school problem, <code class="markup--code markup--p-code">pow(x, n)</code> .</p><p name="3bba" id="3bba" class="graf graf--p graf-after--p">The problem, as you might have guessed, asks us to write a function that will give us the n’th power of x.</p><p name="efe9" id="efe9" class="graf graf--p graf-after--p">A simple and intuitive solution might look like the one right below.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="java" name="e1ee" id="e1ee" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-type">double</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br /><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) {<br />    result *= x;<br />}<br /><span class="hljs-keyword">return</span> result;</span></pre><p name="bc21" id="bc21" class="graf graf--p graf-after--pre">The problem here, for the careless reader, is that for <code class="markup--code markup--p-code">n &lt; 0</code> , this code just returns 1. We can solve this problem by leveraging an algebraic identity, <code class="markup--code markup--p-code">x^-n = (1/x)^n</code> .</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="cpp" name="f9e8" id="f9e8" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) {<br />    x = <span class="hljs-number">1</span> / x;<br />    n = -n;<br />}<br /><span class="hljs-comment">// x^-n = (1/x)^n</span><br /><span class="hljs-type">double</span> result = <span class="hljs-number">1</span>;<br /><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {<br />    result *= x;<br />}<br /><span class="hljs-keyword">return</span> result;</span></pre><p name="4917" id="4917" class="graf graf--p graf-after--pre">This code is indeed a bit slow. It is linear with n, meaning that it takes roughly n multiplications to get to the result. We can get better by using two more algebraic identities, <code class="markup--code markup--p-code">x^2n = (x^2)^n, x^2n+1 = x * x^2n</code> . As you might have realized, we just cut our work in half at each step, resulting in an exponential speed-up.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="cpp" name="a6a8" id="a6a8" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title">pow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> </span>{<br />  <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) {<br />      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br />  }<br />  <br />  <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) {<br />      x = <span class="hljs-number">1</span> / x;<br />      n = -n;<br />  }<br />  <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {<br />      <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(x * x, n / <span class="hljs-number">2</span>);<br />  } <span class="hljs-keyword">else</span> {<br />      <span class="hljs-keyword">return</span> x * <span class="hljs-built_in">pow</span>(x * x, n / <span class="hljs-number">2</span>);<br />  }<br />}</span></pre><p name="0250" id="0250" class="graf graf--p graf-after--pre">How do we make sure that our code is correct, though? The first option is to use a <strong class="markup--strong markup--p-strong">Modeling Property. </strong>We can just compare our results with <code class="markup--code markup--p-code">Math.pow</code> from the Java standart library.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="cpp" name="c19a" id="c19a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-built_in">pow</span>(x, n) == Math.<span class="hljs-built_in">pow</span>(x, n)</span></pre><p name="ce16" id="ce16" class="graf graf--p graf-after--pre">The second option is a less hacky one that actually relies on the <strong class="markup--strong markup--p-strong">meaning </strong>of the pow function.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="cpp" name="8108" id="8108" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-built_in">pow</span>(x, n) * x = <span class="hljs-built_in">pow</span>(x, n + <span class="hljs-number">1</span>)</span></pre><p name="4343" id="4343" class="graf graf--p graf-after--pre">We can just generate many (x, n) pairs, run our pow function for <code class="markup--code markup--p-code">pow(x,n)</code> and <code class="markup--code markup--p-code">pow(x, n+1)</code> separately, and check the results.</p><p name="2d75" id="2d75" class="graf graf--p graf-after--p">One nice feature of using Randomized Property-Based Testing is that it allows for benchmarking our code pretty easily. So, in addition to getting correctness, we get to measure performance. As the inputs are sampled from a large space, timing the results allows for comparing different algorithms easily. Below is the <strong class="markup--strong markup--p-strong">Time vs N graph </strong>obtained by running 4 versions of the <code class="markup--code markup--p-code">pow</code> function I implemented, measured over randomized inputs. The purple line that looks like it’s completely flat is the logarithmic implementation.</p><figure name="db35" id="db35" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*eUlw8qRLDOFf2mkw4sO2RQ.png" data-width="2876" data-height="1520" src="https://cdn-images-1.medium.com/max/800/1*eUlw8qRLDOFf2mkw4sO2RQ.png"></figure><h3 name="492c" id="492c" class="graf graf--h3 graf-after--figure">A More Realistic Example</h3><p name="84cf" id="84cf" class="graf graf--p graf-after--h3">I can hear you saying, come oon, who writes pow these days??? So I come bearing good news, I have a better example.</p><p name="7913" id="7913" class="graf graf--p graf-after--p">There is a board game called <a href="https://en.wikipedia.org/wiki/Quoridor" data-href="https://en.wikipedia.org/wiki/Quoridor" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Quoridor</a> that I started playing recently, and I decided to implement a mobile version of it to play with some friends overseas. Creating a mobile application has many hassles, but the first thing you need to do is to create a model of the game. The game has 81 squares, 144 tile locations, 10 1x2 tiles per player, and 2 pawns. There are several rules governing how tiles can be placed and how pawns can move, but one specific rule is pretty interesting. <strong class="markup--strong markup--p-strong">When placing tiles, opposing player must have at least one path toward their target open, you cannot shut them out.</strong></p><p name="fb68" id="fb68" class="graf graf--p graf-after--p">This can be easily modeled as a <strong class="markup--strong markup--p-strong">Undirected Graph Reachability Problem</strong>. We can model the board as a 9x9 grid, where all adjacent squares have an undirected edge between them if there is no tile. If the pawn can reach any square in the first line of the opposing player after putting a new tile, then the move it valid. Below is a rough picture of the board, showing a path from the mid-top for the white pawn towards the left-bottom.</p><figure name="5e64" id="5e64" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*H4Aq_Uz9WKwepWazxnHLYA.png" data-width="3942" data-height="3280" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*H4Aq_Uz9WKwepWazxnHLYA.png"></figure><p name="2c8e" id="2c8e" class="graf graf--p graf-after--figure">There are two ways of solving this problem. The first is constructing a graph out of the board and running an off the shelf reachability algorithm, the second is to implement a reachability algorithm on top of your own board, which is of course more fun(try to guess which one I decided to do).</p><p name="ac7a" id="ac7a" class="graf graf--p graf-after--p">After implementing a DFS(Depth First Search), I was met with the question of how to verify the correctness of my algorithm, how do I know I’m not too permissive or too restrictive?</p><p name="32ba" id="32ba" class="graf graf--p graf-after--p">I found two such properties.</p><ol class="postList"><li name="e542" id="e542" class="graf graf--li graf-after--p">In the case of a permission, I ask for a witness(a path from the pawn to the target line). I follow through the line to make sure there are not tiles on the way.</li><li name="0b10" id="0b10" class="graf graf--li graf-after--li">In the case of a restriction, things are more complicated. How can you guarantee there are no actual ways? I came up with an interesting solution to this one. I pick a point in the target line, I generate a random non-overlapping walk to the point, and I crush(remove) any tiles on the way, effectively generating at least one path. Running the algorithm again must give me a witness. This is of course a weak property, perhaps my random walks are not uncovering interesting paths that my code is not able to find. I am open to suggestions here!</li></ol><p name="0697" id="0697" class="graf graf--p graf-after--li">I like this because (1) it was directly useful to me in a personal project, (2) it was a case where testing the algorithm was actually pretty hard by hand, (3) the property I came up with was fun to think of.</p><p name="7bf2" id="7bf2" class="graf graf--p graf-after--p">With this, I conclude my examples, and the article. As I said, I believe algorithms come up in many places around software projects, and they are hard to test and verify, especially if you’re not ready for it. I think Randomized Property Based Testing has a pretty good potential for both correctness and performance measurements, and it’s also really fun. If you like property based testing, you can check out my previous article.</p><div name="0846" id="0846" class="graf graf--mixtapeEmbed graf-after--p graf--trailing"><a href="https://medium.com/learning-from-learners/learners-guide-to-property-based-testing-1-ce979c1a58a1" data-href="https://medium.com/learning-from-learners/learners-guide-to-property-based-testing-1-ce979c1a58a1" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://medium.com/learning-from-learners/learners-guide-to-property-based-testing-1-ce979c1a58a1"><strong class="markup--strong markup--mixtapeEmbed-strong">Learner’s Guide to Property Based Testing#1</strong><br><em class="markup--em markup--mixtapeEmbed-em">Property Based Random Testing is a flavor of testing that aims to use higher level specifications for testing instead…</em>medium.com</a><a href="https://medium.com/learning-from-learners/learners-guide-to-property-based-testing-1-ce979c1a58a1" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="19a1af58cac5358feef1ed754df15c73" data-thumbnail-img-id="1*92Av2ZbXV98Ryo1C0cxpFw.png" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/1*92Av2ZbXV98Ryo1C0cxpFw.png);"></a></div></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@alpkeles99" class="p-author h-card">Alperen Keleş</a> on <a href="https://medium.com/p/edf47daf3f88"><time class="dt-published" datetime="2024-03-07T04:20:18.356Z">March 7, 2024</time></a>.</p><p><a href="https://medium.com/@alpkeles99/solving-algorithmic-problems-in-the-wild-edf47daf3f88" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on March 27, 2024.</p></footer></article></body></html>