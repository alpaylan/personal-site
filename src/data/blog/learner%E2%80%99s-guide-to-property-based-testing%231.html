<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Learner’s Guide to Property Based Testing#1</title></head><body><article class="h-entry">

<section data-field="body" class="e-content">
<section name="62c7" class="section section--body section--first section--last"><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="bc17" id="bc17" class="graf graf--h3 graf--leading graf--title">Learner’s Guide to Property Based Testing#1</h3><figure name="aefd" id="aefd" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*92Av2ZbXV98Ryo1C0cxpFw.png" data-width="1640" data-height="924" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*92Av2ZbXV98Ryo1C0cxpFw.png"></figure><p name="2fbe" id="2fbe" class="graf graf--p graf-after--figure">Property Based Random Testing is a flavor of testing that aims to use higher level specifications for testing instead of hand-writing or generating tests. It was first developed by Koen Claessen and John Hughes in 1999 as a software library for Haskell, called QuickCheck. There has been substantial development in the field since then, I will not bore you with lots of details as the purpose of this writing is to familiarize you with PBT(Property Based Testing).</p><p name="8047" id="8047" class="graf graf--p graf-after--p">To give a sense of what is happening, let’s first start by talking about Unit Tests.</p><p name="c0ab" id="c0ab" class="graf graf--p graf-after--p">A Unit Test is a test case aimed into testing a unit of a program, conventionally a function.</p><figure name="ea2b" id="ea2b" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/alpaylan/d4b79f19ff5f50c042c64bb8c9bb8047.js"></script></figure><p name="41ba" id="41ba" class="graf graf--p graf-after--figure">Above, you see a very simple test case for a function called $dummy\_sort$, which from the name and the structure it feels is supposed to sort a given function of possibly integers in ascending order.</p><p name="a73c" id="a73c" class="graf graf--p graf-after--p">But, this test case doesn’t actually give us very much knowledge on the function under test. It gives us a few clues we could perhaps generalize such as;</p><p name="21eb" id="21eb" class="graf graf--p graf-after--p">1- Function sorts the list [2, 1, 3, 4] correctly</p><p name="eaee" id="eaee" class="graf graf--p graf-after--p">2- (1) could imply that the function sorts all lists of length 4 correctly.</p><p name="c25d" id="c25d" class="graf graf--p graf-after--p">3- (1) also could imply that the function sorts all lists of integer permutations from 1 up to n.</p><p name="5ca7" id="5ca7" class="graf graf--p graf-after--p">4- (1) also could imply that the function sorts all lists of all lengths containing positive integers.</p><p name="0fd3" id="0fd3" class="graf graf--p graf-after--p">5- (1) also could imply this function sorts any type of list containing arbitrary integers in arbitrary length.</p><p name="f2cd" id="f2cd" class="graf graf--p graf-after--p">We might be expecting any one of the properties from (1–4), but a better possibility is that we are expecting 5. We could also expect properties 1–4, but the example also wouldn’t generalize to those, at least those other than property (1).</p><p name="3c53" id="3c53" class="graf graf--p graf-after--p">So ideally, we would need to create a set of examples that could represent the set of all cases we want our function to work on, so we need a way of defining this representative.</p><p name="18ee" id="18ee" class="graf graf--p graf-after--p">This is possible via creating what we will call properties in our code. Let me demonstrate with an example.</p><figure name="3e6e" id="3e6e" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/alpaylan/93c49cbfe2b25116733813db18d7fb7b.js"></script></figure><p name="57ef" id="57ef" class="graf graf--p graf-after--figure">Function <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">is_sorted </em></strong>checks if the list is monotonically increasing, meaning if no element is less than the element right before. As a logical statement, we can write <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">is_sorted </em></strong>as</p><figure name="f976" id="f976" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*qj4PFKlqjuaKx-y0fX6m8Q.png" data-width="467" data-height="77" src="https://cdn-images-1.medium.com/max/800/1*qj4PFKlqjuaKx-y0fX6m8Q.png"></figure><p name="af18" id="af18" class="graf graf--p graf-after--figure">If you look carefully, you will see that this property that we wrote actually does not cover our needs. Suppose we have an implementation of <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">dummy_sort</em> </strong>as given below.</p><figure name="0e9e" id="0e9e" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/alpaylan/9e60cb01bf37eaba6fab4d841d788c03.js"></script></figure><p name="40cf" id="40cf" class="graf graf--p graf-after--figure">You will see that this means <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">dummy_sort</em></strong> will always give a sorted list back to you, just not the one you would want.</p><p name="807d" id="807d" class="graf graf--p graf-after--p">So a better property could be writing the test as.</p><figure name="492b" id="492b" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/alpaylan/2539c4d0d7342f6d24ac6137e21ac407.js"></script></figure><p name="f5d3" id="f5d3" class="graf graf--p graf-after--figure">We just added a new check that looks if both lists have the same elements. Which would mean that if <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">l</em></strong> contains an element that <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">sorted_l</em></strong> does not contain, then our function does not do the right thing.</p><p name="ae8a" id="ae8a" class="graf graf--p graf-after--p">Yet, a careful reader will also realize the problem with this property. We can falsify it with the test case given below.</p><figure name="41c2" id="41c2" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/alpaylan/f3d320dc44dc07d010fed2d740462f65.js"></script></figure><p name="febd" id="febd" class="graf graf--p graf-after--figure">As one familiar with Python’s set data structure will see, a set will delete the duplicate elements in a list, hence this property will not be powerful enough too.</p><figure name="928e" id="928e" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/alpaylan/962e02c4c4d864d167e4e45039144ccc.js"></script></figure><p name="c610" id="c610" class="graf graf--p graf-after--figure">So this was our final property for testing. The resulting list must be sorted, and it should be a permutation of the initial list. If I did not do any mistakes in writing the is_permutation function, this function must be properly tested using this property.</p><p name="6e21" id="6e21" class="graf graf--p graf-after--p">There is another way of testing this, we could use a so-called Test Oracle for our property. Let’s say that we tested our <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">dummy_sort</em></strong> extensively, and we used it in our software project for some time, we are quite sure that our function holds. And let’s assume we did not do Property Based Testing the first time, we were young and naive, we only did unit tests on the function, and we now want to use property based testing.</p><p name="94e2" id="94e2" class="graf graf--p graf-after--p">Now, we can use another notion of truth for our new sorting algorithm, whatever <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">dummy_sort </em></strong>returns is our truth.</p><figure name="06fa" id="06fa" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/alpaylan/ace95fd9a8b6fbc392cde41446733f05.js"></script></figure><p name="ad7f" id="ad7f" class="graf graf--p graf-after--figure">As our truth is defined using a previous implementation, we can use that implementation to test our new implementation. This is especially useful for testing optimizations and refactors in our code.</p><p name="3fc7" id="3fc7" class="graf graf--p graf-after--p">So what do we do, we now have a great testing infrastructure, we can just write a bunch of test cases without writing their results as given below.</p><figure name="9ddc" id="9ddc" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/alpaylan/49ac9f3a711790ad27b358eddc24bf32.js"></script></figure><p name="5abe" id="5abe" class="graf graf--p graf-after--figure">It doesn’t seem great, right. We still have to write all of these tests, which is better than writing tests and the results, but still it feels like we could have something better.</p><p name="a5be" id="a5be" class="graf graf--p graf-after--p">Wait, we actually do! John Hughes and Koen Claessen has invented exactly that process.</p><figure name="ccbf" id="ccbf" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/alpaylan/f6d0554608be1bc00e0c78908e2e0c6e.js"></script></figure><p name="4def" id="4def" class="graf graf--p graf-after--figure">Strictly speaking, what they invented is so much greater, fancier, and smarter than this, but it still relies on the same idea. A better version is given below.</p><figure name="2726" id="2726" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/alpaylan/66edcd6e00a0c46d85c16198e10bda5f.js"></script></figure><p name="c975" id="c975" class="graf graf--p graf-after--figure">So what’s better about this process is that</p><p name="e700" id="e700" class="graf graf--p graf-after--p">1- It remembers how many tests it has done, so it can be a bit stateful and remember the past in some sense. A simple example is we can generate lists based on logarithm of i, which would allow creating larger examples as we move forward with the tests, hoping that larger test cases might catch bugs smaller test cases could not demonstrate.</p><p name="b083" id="b083" class="graf graf--p graf-after--p">2- It “shrinks” the failing test case. Shrinking means finding a minimal example using a failed test case. Let’s say that our fancy sorting function has a bug, it crashes when the list has negative numbers. This bug is found with the following test case.</p><pre name="8b40" id="8b40" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">[11, 1,1,1,1,-1,1,2,442,34,2,4]</code></pre><p name="4629" id="4629" class="graf graf--p graf-after--pre">But it could actually be found using.</p><pre name="3d85" id="3d85" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">[-1]</code></pre><p name="fece" id="fece" class="graf graf--p graf-after--pre">If I had given you the first list as the failing case, it would take a lot of time to debug. There are lots of cases, maybe the function crashes with lists of size more than 10, or it cannot handle cases where 4 list elements are same.</p><p name="c23e" id="c23e" class="graf graf--p graf-after--p">But the second test case makes it very clear where the problem is and how to find and debug it.</p><p name="3bfa" id="3bfa" class="graf graf--p graf-after--p">Let me give you a very simple and not-so-smart generator and shrinker for the case given above.</p><figure name="3d68" id="3d68" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/alpaylan/5d58af2914f98c6bdbee76bf9eb9f74c.js"></script></figure><p name="dca0" id="dca0" class="graf graf--p graf-after--figure">This generation function generates random integers from the interval <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">[-5, 10000)</em></strong> for a list of size <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">log2size</em></strong>.</p><figure name="137b" id="137b" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/alpaylan/eb5d8f5f2381d5b09bf7ea821bb2cf96.js"></script></figure><p name="c40d" id="c40d" class="graf graf--p graf-after--figure">This shrinking function tries to shrink the list by truncating it from the beginning. At each step, a smaller list is created by excluding the first element; this allows creating minimal examples for debugging the actual problem.</p><p name="7cb0" id="7cb0" class="graf graf--p graf-after--p">This is the intuition behind Property Based Testing. There is a lot more to talk about, there is fuzzing, mutation based property based testing; there are clever ways of generating, shrinking, testing, writing properties… I want to write about those in the future too, I hope this was an interesting read for you.</p><p name="3f37" id="3f37" class="graf graf--p graf-after--p">For those interested, here are some more interesting reading to follow through.</p><ul class="postList"><li name="629b" id="629b" class="graf graf--li graf-after--p">Original QuickCheck Paper (<a href="https://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quick.pdf" data-href="https://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quick.pdf" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">https://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quick.pdf</a>)</li><li name="6265" id="6265" class="graf graf--li graf-after--li">A Description of Random PBT and Fuzzing explaining motivations behind it by Leo and Mike (<a href="https://plum-umd.github.io/projects/random-testing.html" data-href="https://plum-umd.github.io/projects/random-testing.html" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">https://plum-umd.github.io/projects/random-testing.html</a>)</li><li name="8491" id="8491" class="graf graf--li graf-after--li">A (probably better than mine) medium post on PBT (<a href="https://medium.com/criteo-engineering/introduction-to-property-based-testing-f5236229d237" data-href="https://medium.com/criteo-engineering/introduction-to-property-based-testing-f5236229d237" class="markup--anchor markup--li-anchor" target="_blank">https://medium.com/criteo-engineering/introduction-to-property-based-testing-f5236229d237</a>)</li><li name="3581" id="3581" class="graf graf--li graf-after--li">A talk by John Huges, “Dont Write Tests” (<a href="https://www.youtube.com/watch?v=hXnS_Xjwk2Y" data-href="https://www.youtube.com/watch?v=hXnS_Xjwk2Y" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">https://www.youtube.com/watch?v=hXnS_Xjwk2Y</a>)</li></ul><p name="8088" id="8088" class="graf graf--p graf-after--li">Aside from the gists given above, I also uploaded the code to a single file for anyone interested as a convenience.</p><p name="10dc" id="10dc" class="graf graf--p graf-after--p graf--trailing"><a href="https://github.com/alpaylan/technical-blog-code/blob/main/pbt-1.py" data-href="https://github.com/alpaylan/technical-blog-code/blob/main/pbt-1.py" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://github.com/alpaylan/technical-blog-code/blob/main/pbt-1.py</a></p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@alpkeles99" class="p-author h-card">Alperen Keleş</a> on <a href="https://medium.com/p/ce979c1a58a1"><time class="dt-published" datetime="2021-11-11T04:29:26.672Z">November 11, 2021</time></a>.</p><p><a href="https://medium.com/@alpkeles99/learners-guide-to-property-based-testing-1-ce979c1a58a1" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on March 27, 2024.</p></footer></article></body></html>