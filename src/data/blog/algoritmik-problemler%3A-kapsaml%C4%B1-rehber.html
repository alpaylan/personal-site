<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Algoritmik Problemler: Kapsamlı Rehber</title></head><body><article class="h-entry">

<section data-field="body" class="e-content">
<section name="7acb" class="section section--body section--first section--last"><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="1760" id="1760" class="graf graf--h3 graf--leading graf--title">Algoritmik Problemler: Kapsamlı Rehber</h3><p name="a8e6" id="a8e6" class="graf graf--p graf-after--h3">Bu yazıda, çoğunlukla <a href="http://leetcode.com" data-href="http://leetcode.com" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Leetcode</a> tarzı olarak bahsedilen, aynı zamanda “Competitive Programming”, “Algoritma Sorusu”, “Lanet Olası Algoritmalar” gibi farklı şekillerde de duymuş olabileceğiniz, büyük teknoloji şirketlerinin mülakat süreçlerinde popülerleşmenin ardından pek çok bilgisayar mühendisinin/yazılımcının hayatında ciddi bir yer eden problemler nasıl çözülür, algoritma ve veri yapısı konseptleri nasıl öğrenilir, ne işe yarar, nerede kullanılırı anlatacağım.</p><figure name="577a" id="577a" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*h22XDY1LDFYkuMvTAjnZtA.png" data-width="679" data-height="521" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*h22XDY1LDFYkuMvTAjnZtA.png"></figure><p name="ca74" id="ca74" class="graf graf--p graf-after--figure">Yazıma, sıkça gördüğüm birtakım noktalara kendi bakışımı net bir şekilde koyarak başlamak istiyorum. Yazının kalanı bu kabullere dayanacağı için, eğer katılmıyorsanız bu yazı sizin için faydalı olmayabilir.</p><ol class="postList"><li name="e742" id="e742" class="graf graf--li graf--startsWithDoubleQuote graf-after--p">“Algoritma ya da veri yapısı bilmek” diye bir konsept yok. “Ben Tree biliyorum” diye bir cümle de yok.<strong class="markup--strong markup--li-strong"> “Algoritmik düşünme” insanda zamanla gelişen, belirli bir noktadan sonra yavaşlasa da bitmeyen bir süreçte öğrenilen bir kabiliyet. </strong>Bazı algoritmaların veya veri yapılarının kodunu yazmayı, zaman ve alan kompleksitesini, hangi durumlarda kullanılabileceğini öğrenmiş olabilirsiniz, bu bilgileri pratikte kullanabilmek ise algoritmik düşünme kabiliyetini geliştirmekle bitiyor.</li><li name="0c93" id="0c93" class="graf graf--li graf--startsWithDoubleQuote graf-after--li">“Algoritma problemleri” dünya çapında yaygın kullanılan belli algoritmaları ve veri yapılarını, algoritmik teknikleri, kombinatorik ve olasılık gibi matematiksel konseptleri doğru şekilde birleştirmenizi bekleyen birtakım sorular.</li><li name="5a4d" id="5a4d" class="graf graf--li graf--startsWithDoubleQuote graf-after--li">“Algoritma problemlerini” çözmek gereksiz değil. Gereksiz olduğunu düşünmenin en büyük sebebi, pek çok yazılım projesinde belli özellikleri feda etmenin kolay olması. Performansı yüksek bir kodu her saniye çalıştırabilirken, performansı düşük bir kodu daha az çalıştırmanın yollarını buluyoruz genelde. Algoritmik verimsizlikleri kullanıcı deneyimini o verimsizliği saklayacak şekilde manipüle ederek saklıyoruz. Algoritmik problemleri çözemiyor olmak, o problemlerin oluşturacağı çözümleri yok saymaya gidiyor dolayısıyla. <strong class="markup--strong markup--li-strong">Bugün birisi size ben yazdığım hiçbir kodda algoritma kullanmaya ihtiyaç duymadım diyorsa, demek ki belli özellikleri feda etmiş, ya da daha kötüsü o özelliklerin var olabileceğini düşünmemiş bile.</strong> Burada, bir tip hayatta kalma yanılgısına düşüyor insanlar.</li></ol><figure name="38cc" id="38cc" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*YflzwcBBCcDLXEM14sqcJQ.png" data-width="640" data-height="477" src="https://cdn-images-1.medium.com/max/800/1*YflzwcBBCcDLXEM14sqcJQ.png"></figure><p name="fea7" id="fea7" class="graf graf--p graf-after--figure">Bu kabuller ile yazımıza başlayalım.</p><h3 name="20b6" id="20b6" class="graf graf--h3 graf-after--p">Şimdi sizin aklınızda iki soru var, algoritma sorusu nedir, nasıl çözülür?</h3><p name="6add" id="6add" class="graf graf--p graf-after--h3">Algoritma soruları, her şeyden önce örüntü tanımayı gerektiriyor. Örüntü tanımanın 2 adet temel faydası var.</p><ol class="postList"><li name="1975" id="1975" class="graf graf--li graf-after--p">Soruda verilmiş girdi-çıktı örneklerini kolayca genele yayabilmek için o girdi-çıktılardaki örüntüleri yakalamak gerekiyor.</li><li name="00a4" id="00a4" class="graf graf--li graf-after--li">Algoritmik problemler çoğu zaman özyinelemeli(recursive) yapılara sahip. Bir problemi öz yinelemeli bir şekilde ifade edebilmek de problemin kendi iç örüntülerini tanımayı gerektiriyor.</li></ol><p name="146c" id="146c" class="graf graf--p graf-after--li">Örnek vereyim mesela, benim çok sevdiğim bir leetcode sorusu var, adı da <a href="https://leetcode.com/problems/next-permutation/" data-href="https://leetcode.com/problems/next-permutation/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong">Next Permutation(Sıradaki Sıralama)</strong></a>. Bize herhangi bir dizi veriliyor, dizinin sıradaki permütasyonunu bulmamız isteniyor. Problemin çözümündeki en anahtar adım ise permütasyonun doğası itibariyle özyinelemeli olduğunu fark etmek. Başka bir yazıda bu probleme detaylı bir çözüm yazacağım, ancak şu anda denemek isterseniz oturup biraz çözmeye çalışmanızı tavsiye ederim.</p><p name="c0d6" id="c0d6" class="graf graf--p graf-after--p">Peki neden ben bu soruyu çok seviyorum biliyor musunuz? Normal şartlarda algoritma sorularıyla ilgili yapılan yorumların neredeyse hiçbiri geçerli değil çünkü bu soru için. Bu soruyu herhangi bir dilde çözmek diğerinden daha kolay değil, soru ne bir veri yapısı(linked list, binary search tree vb.) hakkında bilgi gerektiriyor, ne de bir algoritma hakkında. Yapmanız gereken tek şey örüntüleri çözmek.</p><p name="232c" id="232c" class="graf graf--p graf-after--p">Bazı başka sorular böyle değil tabii ki, bazen direkt olarak spesifik bir veri yapısının kendisiyle ilgili sorular geliyor. “Linked List Reversal(ters çevirme) fonksiyonu yaz”, “Binary Search Tree Insertion(eleman ekleme) fonksiyonu yaz” gibi… Bu tarz soruların çözümü ise bu veri yapılarını (1) görselleştirebilmeyi, (2) daha önce yazmış olmayı gerektiriyor. Daha önce hiç Binary Search Tree yazmadıysanız, mülakat esnasında bir anda icat etmeniz çok olası değil.</p><p name="c4f9" id="c4f9" class="graf graf--p graf-after--p">Görselleştirme için 2 adet web sitesi tavsiye ediyorum. Özellikle Tree ve Graph problemleri için problemi ve çözümü kafanızda canlandırabilmek aşırı önemli.</p><ol class="postList"><li name="a6c8" id="a6c8" class="graf graf--li graf-after--p"><a href="https://visualgo.net/en" data-href="https://visualgo.net/en" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">https://visualgo.net/en</a></li><li name="2c9e" id="2c9e" class="graf graf--li graf-after--li"><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" data-href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></li></ol><p name="10f1" id="10f1" class="graf graf--p graf-after--li">Görselleştirme ve pratiğin yanında şahsen bence öğrenebileceğiniz en önemli kabiliyet öz yinelemeli(recursive) düşünmeyi öğrenmek. Recursive düşünmek ne demek peki, biraz da bundan bahsedeyim.</p><figure name="3fdf" id="3fdf" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*U8CIYPa_A71KmRkAxWE8ZQ.jpeg" data-width="1024" data-height="655" src="https://cdn-images-1.medium.com/max/800/1*U8CIYPa_A71KmRkAxWE8ZQ.jpeg"></figure><p name="4f61" id="4f61" class="graf graf--p graf-after--figure">Öz yineleme ile düşünmek, bir problemi kendinden daha küçük parçalara bölüp, problemin çözümünü parçaların çözümü ile birleştirmeye dayanıyor. Örnek veriyorum, bir ağacın derinliğine bakarken, çocuklarının derinliklerinin maksimumuna 1 ekliyoruz aşağıdaki gibi.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="typescript" name="de6a" id="de6a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Tree</span> = { <span class="hljs-attr">tag</span>: <span class="hljs-string">&quot;Node&quot;</span>, <span class="hljs-attr">children</span>: <span class="hljs-title class_">Tree</span>[]} | { <span class="hljs-attr">tag</span>: <span class="hljs-string">&quot;Leaf&quot;</span> }<br /><span class="hljs-keyword">const</span> <span class="hljs-title function_">height</span> = (<span class="hljs-params">tree</span>) =&gt; {<br />  <span class="hljs-keyword">if</span> (tree.<span class="hljs-property">tag</span> === <span class="hljs-string">&quot;Leaf&quot;</span>) {<br />    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br />  } <span class="hljs-keyword">else</span> {<br />    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(tree.<span class="hljs-property">children</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">child</span>) =&gt;</span> child.<span class="hljs-title function_">height</span>()))<br />  }<br />}</span></pre><p name="e996" id="e996" class="graf graf--p graf-after--pre">Burada çözümün mantıklı olma sebebi bir ağacın yüksekliğinin çocuklarının yüksekliklerinin üzerinden tanımlanabiliyor olması. Öz yinelemeyi akılda tutarak kod yazmak da bu tarz bağlantıları sürekli kurmak demek. Bu kod yazma tarzının en büyük avantajı(bence) lokal düşünmeye izin vermesi. Yalnızca şu anda elimizde bulunan ağaca odaklanabiliyoruz çocuklarına hiç bakmadan.</p><h3 name="b3b2" id="b3b2" class="graf graf--h3 graf-after--p">E peki hocam iyi güzel diyorsun da biz nasıl öğreneceğiz bunları?</h3><p name="5050" id="5050" class="graf graf--p graf-after--h3">Bu noktaya kadar dedik ki örüntü çözebilmek lazım, pratik lazım, görselleştirme lazım, recursive düşünme lazım, e peki bunları öğrenmek için en iyi yol nedir? Birisi oturup kurs mu almalı, leetcode mu çözmeli?</p><p name="9c4a" id="9c4a" class="graf graf--p graf-after--p">Bence şahsen öğrenmenin en iyi yolu pratik, ki ben bunu yıllarca bu işin pratiğinden kaçmış bir insan olarak söylüyorum. Bol bol kod yazmak, alışmak gerekiyor. Bir ağaç ya da graf tanımının refleksif olarak omurgadan yazılabilir hale gelmesi gerekiyor. Peki pratiğin ilk aşaması ne? Leetcode kolay soruları çözmek mi mesela?</p><p name="a3d3" id="a3d3" class="graf graf--p graf-after--p">Benim bu konuda şahsen biraz farklı bir görüşüm var. Ben programlamaya aşağıda bıraktığım dökümandaki egzersizleri çözerek başladım. Aşağı, yukarı, ters, düz, içi dolu/boş bir sürü ağaç çizerdim farklı şekillerde. Ağaç egzersizlerinin en iyi tarafı görsel bir çıktının sayının fonksiyonu olarak ortaya çıkması. Bu tarz egzersizler ekstra bir bilgi öğrenme gereği oluşturmadan kendi kendinize algoritmik düşünme kabiliyetini geliştirme fırsatı veriyor başlangıç aşamasında.</p><figure name="422b" id="422b" class="graf graf--figure graf--iframe graf-after--p"></figure><p name="42bd" id="42bd" class="graf graf--p graf-after--figure">Giriş problemlerini bitirdikten sonra, yapılabilecek en iyi şey herhangi bir hazır veri yapısına ya da algoritmaya ihtiyaç duymadığınız problemlerle ilgilenmeye devam etmek iyice rahat hale gelene kadar. Burada çeviri problemleri güzel bir giriş noktası olabilir. <a href="https://leetcode.com/problems/roman-to-integer/" data-href="https://leetcode.com/problems/roman-to-integer/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Roma Rakamlarından Sayıya Çeviri</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt" data-href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">String’den Sayıya Çeviri</a>, <a href="https://leetcode.com/problems/base-7/" data-href="https://leetcode.com/problems/base-7/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Farklı Sayı Tabanları Arasında Çeviri</a>… Benzer şekilde <a href="https://leetcode.com/problems/add-strings/" data-href="https://leetcode.com/problems/add-strings/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">String Halindeki 2 Sayıyı Toplama</a>, <a href="https://leetcode.com/problems/add-binary/" data-href="https://leetcode.com/problems/add-binary/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">İkili Tabanda Toplama</a>, gibi problemlerle ilgilenebilirsiniz. Toplama problemlerini çıkarma/çarpma/bölme için de yapabilirsiniz. Yine herhangi bir algoritma/veri yapısı kullanmadan çözebileceğiniz problemler <a href="https://projecteuler.net/archives" data-href="https://projecteuler.net/archives" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Project Euler Sorularını</a> kullanabilirsiniz.</p><p name="f32c" id="f32c" class="graf graf--p graf-after--p">Bu noktada zaten bir yandan kullanıyor olacağınız Array bazlı problemlerle ilgilenmeye başlayabilirsiniz. Search ve Sort problemleri array ile ilgili en sık göreceğiniz problemler. Burada yapılan en büyük hata ise bunların arkasındaki konseptleri anlamadan koda odaklanmak. Burada 2 adet kod örneği koyalım ortaya neden bahsettiğimi somutlaştırmak için.</p><p name="f873" id="f873" class="graf graf--p graf-after--p">Aşağıda, Google’a Insertion Sort yazdığım ilk çıkan <a href="https://www.geeksforgeeks.org/insertion-sort/" data-href="https://www.geeksforgeeks.org/insertion-sort/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Geeks for Geeks</a>’deki kodu görüyorsunuz.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="javascript" name="d117" id="d117" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">function</span> <span class="hljs-title function_">insertionSort</span>(<span class="hljs-params">arr, n</span>)  <br />{  <br />    <span class="hljs-keyword">let</span> i, key, j;  <br />    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; n; i++) <br />    {  <br />        key = arr[i];  <br />        j = i - <span class="hljs-number">1</span>;  <br />   <br />        <span class="hljs-comment">/* Move elements of arr[0..i-1], that are  <br />        greater than key, to one position ahead  <br />        of their current position */</span><br />        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[j] &gt; key) <br />        {  <br />            arr[j + <span class="hljs-number">1</span>] = arr[j];  <br />            j = j - <span class="hljs-number">1</span>;  <br />        }  <br />        arr[j + <span class="hljs-number">1</span>] = key;  <br />    }  <br />}  </span></pre><p name="c362" id="c362" class="graf graf--p graf-after--pre">Aslında bu kodun çok daha okunabilir bir versiyonu yazılabilir.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="javascript" name="539e" id="539e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment">// 1. Diziyi ikiye ayır, sıralanmış ve sıralanmamış kısım olarak.</span><br /><span class="hljs-comment">// 2. Sıralanmamış dizinin ilk elemanını al, onu sıralanmış dizinin </span><br /><span class="hljs-comment">// içinde doğru yere yerleştir.</span><br /><span class="hljs-comment">// 3. Sıralanmamış dizi bitene kadar devam et.</span><br /><br /><br /><span class="hljs-comment">// Bu fonksiyon, dizinin n&#x27;inci elemanını dizinin 0..n-1&#x27;lik</span><br /><span class="hljs-comment">// baş kısmında ne noktaya yerleştirmesi gerektiğine karar verecek.</span><br /><span class="hljs-keyword">function</span> <span class="hljs-title function_">findSortedPlace</span>(<span class="hljs-params">arr, n</span>) {<br />  <span class="hljs-keyword">let</span> i;<br />  <span class="hljs-comment">// Eğer n&#x27;inci eleman ilk elemandan küçükse, en başa yerleşmeli.</span><br />  <span class="hljs-keyword">if</span> (arr[n] &lt;= arr[<span class="hljs-number">0</span>]) {<br />    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br />  }<br /><br />  <span class="hljs-comment">// Eğer n&#x27;inci eleman dizideki iki elemanın arasındaysa, ikinci</span><br />  <span class="hljs-comment">// elemanın pozisyonuna yerleşmeli.</span><br />  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span> ; i++) {<br />    <span class="hljs-keyword">if</span> (arr[n] &gt;= arr[i] &amp;&amp; arr[n] &lt;= arr[i + <span class="hljs-number">1</span>]) {<br />      <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;<br />    }<br />  }<br />  <br />  <span class="hljs-comment">// Eğer tüm elemanlardan büyükse, yerinde kalmalı.</span><br />  <span class="hljs-keyword">return</span> n<br />   <br />}<br /><br /><span class="hljs-comment">// Bu fonksiyon, dizinin k&#x27;ıncı elemanından itibaren n&#x27;inci</span><br /><span class="hljs-comment">// elemana kadar tüm elemanları 1 sağa kaydırmalı.</span><br /><span class="hljs-keyword">function</span> <span class="hljs-title function_">shiftArray</span>(<span class="hljs-params">arr, k, n</span>) {<br />  <span class="hljs-keyword">let</span> i;<br />  <span class="hljs-comment">// Sağdan sola gidiyoruz ki sildiğimiz elemanları ayrıca tutmak zorunda</span><br />  <span class="hljs-comment">// kalmayalım. Eğer kafanızda oturmuyorsa, soldan sağa gittiğimizde</span><br />  <span class="hljs-comment">// ne olacağını düşünmeyi egzersiz olarak yapabilirsiniz.</span><br />  <span class="hljs-keyword">for</span> (i = n - <span class="hljs-number">1</span>; i &gt;= k ;i--) {<br />    arr[i+<span class="hljs-number">1</span>] = arr[i];<br />  }<br />}<br /><br /><span class="hljs-comment">// Bu fonksiyon, dizinin n&#x27;inci elemanı dizinin 0..n-1&#x27;lik </span><br /><span class="hljs-comment">// baş kısmında doğru yere yerleştirecek.</span><br /><span class="hljs-keyword">function</span> <span class="hljs-title function_">insertSorted</span>(<span class="hljs-params">arr, n</span>) {<br />  <span class="hljs-comment">// Elemanı kaydet.</span><br />  <span class="hljs-keyword">const</span> element = arr[n];<br />  <span class="hljs-comment">// Elemanın gelmesi gereken yeri bul.</span><br />  <span class="hljs-keyword">const</span> place = <span class="hljs-title function_">findSortedPlace</span>(arr, n);<br />  <span class="hljs-comment">// Elemanın geleceği yerden itibaren elemanları kaydır.</span><br />  <span class="hljs-title function_">shiftArray</span>(arr, place, n);<br />  <span class="hljs-comment">// Elemanı yerleştir.</span><br />  arr[place] = element;<br />}</span></pre><p name="ebab" id="ebab" class="graf graf--p graf-after--pre">Probleme bu şekilde hiyerarşik ve fonksiyonel yaklaştığımızda, i = n mi olacaktı n-1 mi gibi tartışmaları geride bırakabiliyoruz. Çünkü aslında bu algoritmaların hepsinin kendi içinde belli bir yapısı, bir hiyerarşisi, bir sistemi var. Geeks for Geeks gibi sitelerdeki kodların en büyük problemi bu hiyerarşiyi yok etmeleri, arkadaki konseptleri silmeleri.</p><p name="84d0" id="84d0" class="graf graf--p graf-after--p">Search ve Sort problemlerinden sonra artık ilk dil dışı veri yapınızla ilgilenmeye başlayabilirsiniz, Linked List. Burada önemli olan nokta, kullandığınız dillerin sizlere Array’ler ile uğraşmak için çok ciddi bir altyapı sağlıyor olması. Kendi veri yapınızda böyle bir lüksünüz yok, her detayla sizin ilgilenmeniz gerekiyor. Aynı şekilde, Linked List’e geçerken bir de parantez açmak gerek, çünkü genelde “Linked List ne abi hiçbir zaman kullanmayacağım napıyorum” gibi bir bakış açısı var.</p><blockquote name="e1b0" id="e1b0" class="graf graf--blockquote graf-after--p">Linked List, karşınıza çıkabilecek en basit veri yapılarından bir tanesi. Linked List sorulara da size Graph ya da Tree gibi yapıların sorularını çözmeye yardımcı olacak refleksler kazandırıyor. Görselleştirmenin işe yaradığı ilk problem Linked List mesela. Linked List sorularını çözmeden de bu konseptleri öğrenebilirsiniz tabii ki, ama toplama öğrenmeden çarpma öğrenmeye eşdeğer bir durumla karşılaşıyor olma şansınız çok yüksek.</blockquote><p name="b6fd" id="b6fd" class="graf graf--p graf-after--blockquote">Linked List ile ilgili konseptleri öğrenmek için, bir Linked List’in arayüzünü yazmak yeterli bence çoğu zaman. Favori dilinizdeki Array/Vector kütüphanesindeki fonksiyonlardan ilginizi çekenleri(insert, find, remove, index, length, reverse, merge, concat) doğru bir şekilde yazıp test edebiliyorsanız, kalan yolda stack, queue, deque, binary tree, nary tree, heap, graph vb gibi çok fazla veri yapısı var. Bunların hepsini tabii ki bir tane blog yazısında tartışmayacağım, ancak neden önemli olduklarını biraz konuşmak lazım.</p><h4 name="4381" id="4381" class="graf graf--h4 graf-after--p">Personal Opinion Alert!</h4><p name="0e36" id="0e36" class="graf graf--p graf-after--h4">Bir yazılımcının asıl işi kod yazmak değil. Kod yazmak bir araç, bir yazılımcının asıl işi modelleme yapmak. Kullanıcının aksiyonlarını, uygulamadaki verileri, verilerin kullanıcıya nasıl sunulduğunu modellemek, bunların arasında bir ilişki kurmak. Eğer ki siz, yazılımcı olarak doğru modelleme araçlarına sahip değilseniz, o noktada <a href="https://eksisozluk1923.com/elinde-cekic-olan-her-seyi-civi-sanir--830764" data-href="https://eksisozluk1923.com/elinde-cekic-olan-her-seyi-civi-sanir--830764" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">elinde sadece çekiç olan ustaya</a> benzersiniz. Üzerine çalıştığınız problemde bir ağaç yapısı gördüğünüzde onu tanıyamazsanız, onu bir array ile modelleyebilirsiniz tabii ki. Elimizde tarihin gördüğü en güçlü makineler var, saniyede milyonlarca işlem yapabiliyorlar sonuçta, bir ağaçta 10 işlem yapmak yerine bir array’de 1000 işlem yapmak çoğu zaman bir problem değil, problem olduğu noktaya kadar. Ölçek büyüdükçe, daha fazla kullanıcıya ulaştıkça, daha fazla problem çözdükçe, aynı anda daha fazla kod çalıştırdıkça yanlış modellemenin getirdiği verimsizlikler birikmeye başlıyor. O noktada da en başta hayatta kalma yanılgısı ile bahsettiğim gibi, çoğu zaman eldeki imkanlar neticesinde kullanıcı arayüzleri dizayn ediliyor, aslında kullanıcıya daha iyi hizmet verebilecek özellikler belki de hiçbir zaman sahaya sürülmüyor, tartışılmıyor. Bir kodu kullanıcının her mouse hareketinde çalıştırmakla, her klavyeye basışında çalıştırmakla, her kaydet butonuna bastığında çalıştırmak arasındaki en büyük fark, bu kodun ne kadar hızlı çalışabildiği oluyor bir noktada.</p><h3 name="1dbe" id="1dbe" class="graf graf--h3 graf-after--p">Toplayıp Kapatalım</h3><p name="bf0e" id="bf0e" class="graf graf--p graf-after--h3">Biraz dağınık bir yazı oldu, ben de kendi kafamı aşırı toplayamadım ama yayınlıyorum artık bu şekilde şimdilik, sonrasında güncellerim biraz da belki.</p><ol class="postList"><li name="0484" id="0484" class="graf graf--li graf-after--p">Algoritmik problem çözmenin temellerinde örüntü tanıma, öz yinelemeli düşünebilme, yaygın veri yapıları ve algoritmalarla haşır neşir olma, bol bol pratik yapma var.</li><li name="fcc4" id="fcc4" class="graf graf--li graf-after--li">Algoritmik problem çözme kabiliyetini geliştirebilmek için yazıda benim şahsen mantıklı gördüğüm aşırı da detaylandırılmamış bir yol haritası var. Veri yapıları ve algoritmalara girmeden daha basit, mantıksal ve matematiksel problemlerle başlayan, sonrasında Linked List/Binary Tree gibi basit yapıların kendi arayüzlerini yazmakla devam eden. Deneyip yorum yapan olursa yorumlarını beklerim.</li><li name="3c11" id="3c11" class="graf graf--li graf-after--li">(bence) Bu konseptleri öğrenmek sizi daha iyi bir mühendis yapacak.</li></ol><p name="05d1" id="05d1" class="graf graf--p graf-after--li graf--trailing">Umarım faydalı bir yazı olmuştur, buraya kadar okuyan herkese teşekkür ediyorum, iyi günler dilerim.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@alpkeles99" class="p-author h-card">Alperen Keleş</a> on <a href="https://medium.com/p/ec3ee7e4d986"><time class="dt-published" datetime="2023-11-01T15:56:14.843Z">November 1, 2023</time></a>.</p><p><a href="https://medium.com/@alpkeles99/algoritmik-problemler-kapsaml%C4%B1-rehber-ec3ee7e4d986" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on March 27, 2024.</p></footer></article></body></html>